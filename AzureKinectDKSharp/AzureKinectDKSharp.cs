// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace AzureKinectDKSharp
{
    namespace K4a
    {
        /// <summary>Exception type thrown when a K4A API call fails</summary>
        public unsafe partial class Error : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr vfptr_exception;

                [FieldOffset(8)]
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0error@k4a@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0error@k4a@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0error@k4a@@QEAA@PEBD@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPStr)] string _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4a.Error> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4a.Error>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::AzureKinectDKSharp.K4a.Error __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Error(native.ToPointer(), skipVTables);
            }

            internal static global::AzureKinectDKSharp.K4a.Error __CreateInstance(global::AzureKinectDKSharp.K4a.Error.__Internal native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Error(native, skipVTables);
            }

            private static void* __CopyValue(global::AzureKinectDKSharp.K4a.Error.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Error.__Internal));
                global::AzureKinectDKSharp.K4a.Error.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Error(global::AzureKinectDKSharp.K4a.Error.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Error(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                if (skipVTables)
                    __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
                else
                    SetupVTables(true);
            }

            public Error()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Error.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "AzureKinectDKSharp.K4a.Error");
            }

            public Error(global::AzureKinectDKSharp.K4a.Error _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Error.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                SetupVTables(GetType().FullName == "AzureKinectDKSharp.K4a.Error");
            }

            public Error(string _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Error.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment), _0);
                SetupVTables(GetType().FullName == "AzureKinectDKSharp.K4a.Error");
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::AzureKinectDKSharp.K4a.Error __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::AzureKinectDKSharp.K4a.Error.__Internal*) __Instance)->vfptr_exception = new global::System.IntPtr(__OriginalVTables[0]);
                if (disposing)
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                    var ___dtorDelegate = (global::AzureKinectDKSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::AzureKinectDKSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::AzureKinectDKSharp.K4a.Error(string _0)
            {
                return new global::AzureKinectDKSharp.K4a.Error(_0);
            }

            #region Virtual table interop

            // error
            private static global::AzureKinectDKSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(global::System.IntPtr __instance, int delete)
            {
                if (!NativeToManagedMap.ContainsKey(__instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::AzureKinectDKSharp.K4a.Error) NativeToManagedMap[__instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.Dispose(true);
            }

            private static void*[] __ManagedVTables;
            private static void*[] __ManagedVTablesDtorOnly;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (_Thunks == null)
                {
                    _Thunks = new void*[1];
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                }

                if (destructorOnly)
                {
                    if (__ManagedVTablesDtorOnly == null)
                    {
                        __ManagedVTablesDtorOnly = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                }
                else
                {
                    if (__ManagedVTables == null)
                    {
                        __ManagedVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                        __ManagedVTables[0] = vfptr0.ToPointer();
                        *(void**) (vfptr0 + 0) = _Thunks[0];
                        *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                    }

                    *(void**) (__Instance + 0) = __ManagedVTables[0];
                }
            }

            #endregion
        }

        /// <summary>Wrapper for</summary>
/// <remarks>
/// <para>Wraps a handle for an image.  Copying/moving is cheap, copies are shallow.</para>
/// <para>k4a_image_t</para>
/// </remarks>
        public unsafe partial class Image : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr m_handle;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0image@k4a@@QEAA@PEAU_k4a_image_t@@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::System.IntPtr handle);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0image@k4a@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr __instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1image@k4a@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr __instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??8image@k4a@@QEBA_NAEBV01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(global::System.IntPtr __instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??9image@k4a@@QEBA_NAEBV01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(global::System.IntPtr __instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??Bimage@k4a@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@image@k4a@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?create@image@k4a@@SA?AV12@W4k4a_image_format_t@@HHH@Z")]
                internal static extern void Create(global::System.IntPtr @return, global::AzureKinectDKSharp.K4aImageFormatT format, int width_pixels, int height_pixels, int stride_bytes);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?create_from_buffer@image@k4a@@SA?AV12@W4k4a_image_format_t@@HHHPEAE_KP6AXPEAX3@Z3@Z")]
                internal static extern void CreateFromBuffer(global::System.IntPtr @return, global::AzureKinectDKSharp.K4aImageFormatT format, int width_pixels, int height_pixels, int stride_bytes, byte* buffer, ulong buffer_size, global::System.IntPtr buffer_release_cb, global::System.IntPtr buffer_release_cb_context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?set_white_balance@image@k4a@@QEAAXI@Z")]
                internal static extern void SetWhiteBalance(global::System.IntPtr __instance, uint white_balance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?set_iso_speed@image@k4a@@QEAAXI@Z")]
                internal static extern void SetIsoSpeed(global::System.IntPtr __instance, uint iso_speed);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?handle@image@k4a@@QEBAPEAU_k4a_image_t@@XZ")]
                internal static extern global::System.IntPtr Handle(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_buffer@image@k4a@@QEAAPEAEXZ")]
                internal static extern byte* GetBuffer(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_size@image@k4a@@QEBA_KXZ")]
                internal static extern ulong GetSize(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_format@image@k4a@@QEBA?AW4k4a_image_format_t@@XZ")]
                internal static extern global::AzureKinectDKSharp.K4aImageFormatT GetFormat(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_width_pixels@image@k4a@@QEBAHXZ")]
                internal static extern int GetWidthPixels(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_height_pixels@image@k4a@@QEBAHXZ")]
                internal static extern int GetHeightPixels(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_stride_bytes@image@k4a@@QEBAHXZ")]
                internal static extern int GetStrideBytes(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_white_balance@image@k4a@@QEBAIXZ")]
                internal static extern uint GetWhiteBalance(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_iso_speed@image@k4a@@QEBAIXZ")]
                internal static extern uint GetIsoSpeed(global::System.IntPtr __instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4a.Image> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4a.Image>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::AzureKinectDKSharp.K4a.Image __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Image(native.ToPointer(), skipVTables);
            }

            internal static global::AzureKinectDKSharp.K4a.Image __CreateInstance(global::AzureKinectDKSharp.K4a.Image.__Internal native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Image(native, skipVTables);
            }

            private static void* __CopyValue(global::AzureKinectDKSharp.K4a.Image.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Image.__Internal));
                global::AzureKinectDKSharp.K4a.Image.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Image(global::AzureKinectDKSharp.K4a.Image.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Image(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
/// <para>Creates an image from a k4a_image_t.</para>
/// <para>Takes ownership of the handle, i.e. assuming that handle has a refcount</para>
/// <para>of 1, you should not call k4a_image_release on the handle after giving</para>
/// <para>it to the image; the image will take care of that.</para>
/// </summary>
            public Image(global::AzureKinectDKSharp.K4aImageT handle)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Image.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Creates a shallow copy of another image</summary>
            public Image(global::AzureKinectDKSharp.K4a.Image other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Image.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::AzureKinectDKSharp.K4a.Image __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Returns true if two images refer to the same k4a_image_t, false otherwise</summary>
            public static bool operator ==(global::AzureKinectDKSharp.K4a.Image __op, global::AzureKinectDKSharp.K4a.Image other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool otherNull = ReferenceEquals(other, null);
                if (__opNull || otherNull)
                    return __opNull && otherNull;
                var __arg0 = __op.__Instance;
                var __arg1 = other.__Instance;
                var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::AzureKinectDKSharp.K4a.Image;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(global::AzureKinectDKSharp.K4a.Image.__Internal*) __Instance).GetHashCode();
            }

            /// <summary>Returns true if two images wrap different k4a_image_t instances, false otherwise</summary>
            public static bool operator !=(global::AzureKinectDKSharp.K4a.Image __op, global::AzureKinectDKSharp.K4a.Image other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool otherNull = ReferenceEquals(other, null);
                if (__opNull || otherNull)
                    return !(__opNull && otherNull);
                var __arg0 = __op.__Instance;
                var __arg1 = other.__Instance;
                var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return __ret;
            }

            /// <summary>Returns true if the image is valid, false otherwise</summary>
            public static implicit operator bool(global::AzureKinectDKSharp.K4a.Image __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var __ret = __Internal.OperatorConversion(__arg0);
                return __ret;
            }

            /// <summary>Releases the underlying k4a_image_t; the image is set to invalid.</summary>
            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Set the white balance of the image (color images only)</summary>
/// <remarks>k4a_image_set_white_balance</remarks>
            public void SetWhiteBalance(uint white_balance)
            {
                __Internal.SetWhiteBalance((__Instance + __PointerAdjustment), white_balance);
            }

            /// <summary>Set the ISO speed of the image (color images only)</summary>
/// <remarks>k4a_image_set_iso_speed</remarks>
            public void SetIsoSpeed(uint iso_speed)
            {
                __Internal.SetIsoSpeed((__Instance + __PointerAdjustment), iso_speed);
            }

            public static implicit operator global::AzureKinectDKSharp.K4a.Image(global::AzureKinectDKSharp.K4aImageT handle)
            {
                return new global::AzureKinectDKSharp.K4a.Image(handle);
            }

            /// <summary>
/// <para>Create a blank image</para>
/// <para>Throws error on failure</para>
/// </summary>
/// <remarks>k4a_image_create</remarks>
            public static global::AzureKinectDKSharp.K4a.Image Create(global::AzureKinectDKSharp.K4aImageFormatT format, int width_pixels, int height_pixels, int stride_bytes)
            {
                var __ret = new global::AzureKinectDKSharp.K4a.Image.__Internal();
                __Internal.Create(new IntPtr(&__ret), format, width_pixels, height_pixels, stride_bytes);
                return global::AzureKinectDKSharp.K4a.Image.__CreateInstance(__ret);
            }

            /// <summary>
/// <para>Create an image from a pre-allocated buffer</para>
/// <para>Throws error on failure</para>
/// </summary>
/// <remarks>k4a_image_create_from_buffer</remarks>
            public static global::AzureKinectDKSharp.K4a.Image CreateFromBuffer(global::AzureKinectDKSharp.K4aImageFormatT format, int width_pixels, int height_pixels, int stride_bytes, byte* buffer, ulong buffer_size, global::AzureKinectDKSharp.K4aMemoryDestroyCbT buffer_release_cb, global::System.IntPtr buffer_release_cb_context)
            {
                var __arg6 = buffer_release_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(buffer_release_cb);
                var __ret = new global::AzureKinectDKSharp.K4a.Image.__Internal();
                __Internal.CreateFromBuffer(new IntPtr(&__ret), format, width_pixels, height_pixels, stride_bytes, buffer, buffer_size, __arg6, buffer_release_cb_context);
                return global::AzureKinectDKSharp.K4a.Image.__CreateInstance(__ret);
            }

            /// <summary>Returns the underlying k4a_image_t handle</summary>
            public global::AzureKinectDKSharp.K4aImageT Handle
            {
                get
                {
                    var __ret = __Internal.Handle((__Instance + __PointerAdjustment));
                    global::AzureKinectDKSharp.K4aImageT __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::AzureKinectDKSharp.K4aImageT.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::AzureKinectDKSharp.K4aImageT) global::AzureKinectDKSharp.K4aImageT.NativeToManagedMap[__ret];
                    else __result0 = global::AzureKinectDKSharp.K4aImageT.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>Get the image buffer</summary>
/// <remarks>k4a_image_get_buffer</remarks>
            public byte* Buffer
            {
                get
                {
                    var __ret = __Internal.GetBuffer((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the image buffer size in bytes</summary>
/// <remarks>k4a_image_get_size</remarks>
            public ulong Size
            {
                get
                {
                    var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the image format of the image</summary>
/// <remarks>k4a_image_get_format</remarks>
            public global::AzureKinectDKSharp.K4aImageFormatT Format
            {
                get
                {
                    var __ret = __Internal.GetFormat((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the image width in pixels</summary>
/// <remarks>k4a_image_get_width_pixels</remarks>
            public int WidthPixels
            {
                get
                {
                    var __ret = __Internal.GetWidthPixels((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the image height in pixels</summary>
/// <remarks>k4a_image_get_height_pixels</remarks>
            public int HeightPixels
            {
                get
                {
                    var __ret = __Internal.GetHeightPixels((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the image stride in bytes</summary>
/// <remarks>k4a_image_get_stride_bytes</remarks>
            public int StrideBytes
            {
                get
                {
                    var __ret = __Internal.GetStrideBytes((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the image white balance in Kelvin (color images only)</summary>
/// <remarks>k4a_image_get_white_balance</remarks>
            public uint WhiteBalance
            {
                get
                {
                    var __ret = __Internal.GetWhiteBalance((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>Get the image's ISO speed (color images only)</summary>
/// <remarks>k4a_image_get_white_balance</remarks>
            public uint IsoSpeed
            {
                get
                {
                    var __ret = __Internal.GetIsoSpeed((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Wrapper for</summary>
/// <remarks>Wraps a handle for a capture.  Copying/moving is cheap, copies are shallow.</remarks>
        public unsafe partial class Capture : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr m_handle;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0capture@k4a@@QEAA@PEAU_k4a_capture_t@@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::System.IntPtr handle);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0capture@k4a@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr __instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1capture@k4a@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr __instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??8capture@k4a@@QEBA_NAEBV01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(global::System.IntPtr __instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??9capture@k4a@@QEBA_NAEBV01@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(global::System.IntPtr __instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??Bcapture@k4a@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?reset@capture@k4a@@QEAAXXZ")]
                internal static extern void Reset(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?set_color_image@capture@k4a@@QEAAXAEBVimage@2@@Z")]
                internal static extern void SetColorImage(global::System.IntPtr __instance, global::System.IntPtr color_image);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?set_depth_image@capture@k4a@@QEAAXAEBVimage@2@@Z")]
                internal static extern void SetDepthImage(global::System.IntPtr __instance, global::System.IntPtr depth_image);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?set_ir_image@capture@k4a@@QEAAXAEBVimage@2@@Z")]
                internal static extern void SetIrImage(global::System.IntPtr __instance, global::System.IntPtr ir_image);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?set_temperature_c@capture@k4a@@QEAAXM@Z")]
                internal static extern void SetTemperatureC(global::System.IntPtr __instance, float temperature_c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?create@capture@k4a@@SA?AV12@XZ")]
                internal static extern void Create(global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_color_image@capture@k4a@@QEBA?AVimage@2@XZ")]
                internal static extern void GetColorImage(global::System.IntPtr __instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_depth_image@capture@k4a@@QEBA?AVimage@2@XZ")]
                internal static extern void GetDepthImage(global::System.IntPtr __instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_ir_image@capture@k4a@@QEBA?AVimage@2@XZ")]
                internal static extern void GetIrImage(global::System.IntPtr __instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_temperature_c@capture@k4a@@QEBAMXZ")]
                internal static extern float GetTemperatureC(global::System.IntPtr __instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4a.Capture> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4a.Capture>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::AzureKinectDKSharp.K4a.Capture __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Capture(native.ToPointer(), skipVTables);
            }

            internal static global::AzureKinectDKSharp.K4a.Capture __CreateInstance(global::AzureKinectDKSharp.K4a.Capture.__Internal native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Capture(native, skipVTables);
            }

            private static void* __CopyValue(global::AzureKinectDKSharp.K4a.Capture.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Capture.__Internal));
                global::AzureKinectDKSharp.K4a.Capture.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private Capture(global::AzureKinectDKSharp.K4a.Capture.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Capture(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
/// <para>Creates a capture from a k4a_capture_t</para>
/// <para>Takes ownership of the handle, i.e. assuming that handle has a refcount</para>
/// <para>of 1, you should not call k4a_capture_release on the handle after giving</para>
/// <para>it to the capture; the capture will take care of that.</para>
/// </summary>
            public Capture(global::AzureKinectDKSharp.K4aCaptureT handle)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Capture.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Creates a shallow copy of another capture</summary>
            public Capture(global::AzureKinectDKSharp.K4a.Capture other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Capture.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::AzureKinectDKSharp.K4a.Capture __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Returns true if two captures refer to the same k4a_capture_t, false otherwise</summary>
            public static bool operator ==(global::AzureKinectDKSharp.K4a.Capture __op, global::AzureKinectDKSharp.K4a.Capture other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool otherNull = ReferenceEquals(other, null);
                if (__opNull || otherNull)
                    return __opNull && otherNull;
                var __arg0 = __op.__Instance;
                var __arg1 = other.__Instance;
                var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::AzureKinectDKSharp.K4a.Capture;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(global::AzureKinectDKSharp.K4a.Capture.__Internal*) __Instance).GetHashCode();
            }

            /// <summary>Returns true if two captures wrap different k4a_capture_t instances, false otherwise</summary>
            public static bool operator !=(global::AzureKinectDKSharp.K4a.Capture __op, global::AzureKinectDKSharp.K4a.Capture other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool otherNull = ReferenceEquals(other, null);
                if (__opNull || otherNull)
                    return !(__opNull && otherNull);
                var __arg0 = __op.__Instance;
                var __arg1 = other.__Instance;
                var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return __ret;
            }

            /// <summary>Returns true if the capture is valid, false otherwise</summary>
            public static implicit operator bool(global::AzureKinectDKSharp.K4a.Capture __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var __ret = __Internal.OperatorConversion(__arg0);
                return __ret;
            }

            /// <summary>Releases the underlying k4a_capture_t; the capture is set to invalid.</summary>
            public void Reset()
            {
                __Internal.Reset((__Instance + __PointerAdjustment));
            }

            /// <summary>Set / add a color image to the capture</summary>
/// <remarks>k4a_capture_set_color_image</remarks>
            public void SetColorImage(global::AzureKinectDKSharp.K4a.Image color_image)
            {
                if (ReferenceEquals(color_image, null))
                    throw new global::System.ArgumentNullException("color_image", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = color_image.__Instance;
                __Internal.SetColorImage((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Set / add a depth image to the capture</summary>
/// <remarks>k4a_capture_set_depth_image</remarks>
            public void SetDepthImage(global::AzureKinectDKSharp.K4a.Image depth_image)
            {
                if (ReferenceEquals(depth_image, null))
                    throw new global::System.ArgumentNullException("depth_image", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = depth_image.__Instance;
                __Internal.SetDepthImage((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Set / add an IR image to the capture</summary>
/// <remarks>k4a_capture_set_ir_image</remarks>
            public void SetIrImage(global::AzureKinectDKSharp.K4a.Image ir_image)
            {
                if (ReferenceEquals(ir_image, null))
                    throw new global::System.ArgumentNullException("ir_image", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = ir_image.__Instance;
                __Internal.SetIrImage((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Set the temperature associated with the capture in Celsius.</summary>
/// <remarks>k4a_capture_set_temperature_c</remarks>
            public void SetTemperatureC(float temperature_c)
            {
                __Internal.SetTemperatureC((__Instance + __PointerAdjustment), temperature_c);
            }

            public static implicit operator global::AzureKinectDKSharp.K4a.Capture(global::AzureKinectDKSharp.K4aCaptureT handle)
            {
                return new global::AzureKinectDKSharp.K4a.Capture(handle);
            }

            /// <summary>
/// <para>Create an empty capture object.</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_capture_create</remarks>
            public static global::AzureKinectDKSharp.K4a.Capture Create()
            {
                var __ret = new global::AzureKinectDKSharp.K4a.Capture.__Internal();
                __Internal.Create(new IntPtr(&__ret));
                return global::AzureKinectDKSharp.K4a.Capture.__CreateInstance(__ret);
            }

            /// <summary>Get the color image associated with the capture</summary>
/// <remarks>k4a_capture_get_color_image</remarks>
            public global::AzureKinectDKSharp.K4a.Image ColorImage
            {
                get
                {
                    var __ret = new global::AzureKinectDKSharp.K4a.Image.__Internal();
                    __Internal.GetColorImage((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::AzureKinectDKSharp.K4a.Image.__CreateInstance(__ret);
                }
            }

            /// <summary>Get the depth image associated with the capture</summary>
/// <remarks>k4a_capture_get_depth_image</remarks>
            public global::AzureKinectDKSharp.K4a.Image DepthImage
            {
                get
                {
                    var __ret = new global::AzureKinectDKSharp.K4a.Image.__Internal();
                    __Internal.GetDepthImage((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::AzureKinectDKSharp.K4a.Image.__CreateInstance(__ret);
                }
            }

            /// <summary>Get the IR image associated with the capture</summary>
/// <remarks>k4a_capture_get_ir_image</remarks>
            public global::AzureKinectDKSharp.K4a.Image IrImage
            {
                get
                {
                    var __ret = new global::AzureKinectDKSharp.K4a.Image.__Internal();
                    __Internal.GetIrImage((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::AzureKinectDKSharp.K4a.Image.__CreateInstance(__ret);
                }
            }

            /// <summary>Get temperature (in Celsius) associated with the capture.</summary>
/// <remarks>k4a_capture_get_temperature_c</remarks>
            public float TemperatureC
            {
                get
                {
                    var __ret = __Internal.GetTemperatureC((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        /// <summary>Wrapper for</summary>
/// <remarks>Provides member functions for k4a_calibration_t.</remarks>
        public unsafe partial class Calibration : global::AzureKinectDKSharp.K4aCalibrationT, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 1032)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal depth_camera_calibration;

                [FieldOffset(128)]
                internal global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal color_camera_calibration;

                [FieldOffset(256)]
                internal fixed byte extrinsics[16];

                [FieldOffset(1024)]
                internal global::AzureKinectDKSharp.K4aDepthModeT depth_mode;

                [FieldOffset(1028)]
                internal global::AzureKinectDKSharp.K4aColorResolutionT color_resolution;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0calibration@k4a@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?convert_3d_to_3d@calibration@k4a@@QEBA?ATk4a_float3_t@@AEBT3@W4k4a_calibration_type_t@@1@Z")]
                internal static extern void Convert3dTo3d(global::System.IntPtr __instance, global::System.IntPtr @return, global::System.IntPtr source_point3d, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?convert_2d_to_3d@calibration@k4a@@QEBA_NAEBTk4a_float2_t@@MW4k4a_calibration_type_t@@1PEATk4a_float3_t@@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Convert2dTo3d(global::System.IntPtr __instance, global::System.IntPtr source_point2d, float source_depth, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::System.IntPtr target_point3d);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?convert_3d_to_2d@calibration@k4a@@QEBA_NAEBTk4a_float3_t@@W4k4a_calibration_type_t@@1PEATk4a_float2_t@@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Convert3dTo2d(global::System.IntPtr __instance, global::System.IntPtr source_point3d, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::System.IntPtr target_point2d);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?convert_2d_to_2d@calibration@k4a@@QEBA_NAEBTk4a_float2_t@@MW4k4a_calibration_type_t@@1PEAT3@@Z")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Convert2dTo2d(global::System.IntPtr __instance, global::System.IntPtr source_point2d, float source_depth, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::System.IntPtr target_point2d);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_from_raw@calibration@k4a@@SA?AU12@PEAD_KW4k4a_depth_mode_t@@W4k4a_color_resolution_t@@@Z")]
                internal static extern void GetFromRaw(global::System.IntPtr @return, sbyte* raw_calibration, ulong raw_calibration_size, global::AzureKinectDKSharp.K4aDepthModeT depth_mode, global::AzureKinectDKSharp.K4aColorResolutionT color_resolution);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_from_raw@calibration@k4a@@SA?AU12@PEAE_KW4k4a_depth_mode_t@@W4k4a_color_resolution_t@@@Z")]
                internal static extern void GetFromRaw_1(global::System.IntPtr @return, byte* raw_calibration, ulong raw_calibration_size, global::AzureKinectDKSharp.K4aDepthModeT depth_mode, global::AzureKinectDKSharp.K4aColorResolutionT color_resolution);
            }

            internal static new global::AzureKinectDKSharp.K4a.Calibration __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Calibration(native.ToPointer(), skipVTables);
            }

            internal static global::AzureKinectDKSharp.K4a.Calibration __CreateInstance(global::AzureKinectDKSharp.K4a.Calibration.__Internal native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Calibration(native, skipVTables);
            }

            private static void* __CopyValue(global::AzureKinectDKSharp.K4a.Calibration.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Calibration.__Internal));
                *(global::AzureKinectDKSharp.K4a.Calibration.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Calibration(global::AzureKinectDKSharp.K4a.Calibration.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Calibration(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Calibration()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Calibration.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Calibration(global::AzureKinectDKSharp.K4a.Calibration _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Calibration.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::AzureKinectDKSharp.K4a.Calibration.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4a.Calibration.__Internal*) _0.__Instance);
            }

            /// <summary>
/// <para>Transform a 3d point of a source coordinate system into a 3d point of the target coordinate system.</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_calibration_3d_to_3d</remarks>
            public global::AzureKinectDKSharp.K4aFloat3T Convert3dTo3d(global::AzureKinectDKSharp.K4aFloat3T source_point3d, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera)
            {
                var ____arg0 = source_point3d.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var __ret = new global::AzureKinectDKSharp.K4aFloat3T.__Internal();
                __Internal.Convert3dTo3d((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, source_camera, target_camera);
                return global::AzureKinectDKSharp.K4aFloat3T.__CreateInstance(__ret);
            }

            /// <summary>
/// <para>Transform a 2d pixel coordinate with an associated depth value of the source camera into a 3d point of the</para>
/// <para>target coordinate system.</para>
/// <para>Returns false if the point is invalid in the target coordinate system (and therefore target_point3d should not be</para>
/// <para>used)</para>
/// <para>Throws error if calibration contains invalid data.</para>
/// </summary>
/// <remarks>k4a_calibration_2d_to_3d</remarks>
            public bool Convert2dTo3d(global::AzureKinectDKSharp.K4aFloat2T source_point2d, float source_depth, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::AzureKinectDKSharp.K4aFloat3T target_point3d)
            {
                var ____arg0 = source_point2d.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var ____arg4 = target_point3d.__Instance;
                var __arg4 = new global::System.IntPtr(&____arg4);
                var __ret = __Internal.Convert2dTo3d((__Instance + __PointerAdjustment), __arg0, source_depth, source_camera, target_camera, __arg4);
                return __ret;
            }

            /// <summary>
/// <para>Transform a 3d point of a source coordinate system into a 2d pixel coordinate of the target camera.</para>
/// <para>Returns false if the point is invalid in the target coordinate system (and therefore target_point2d should not be</para>
/// <para>used)</para>
/// <para>Throws error if calibration contains invalid data.</para>
/// </summary>
/// <remarks>k4a_calibration_3d_to_2d</remarks>
            public bool Convert3dTo2d(global::AzureKinectDKSharp.K4aFloat3T source_point3d, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::AzureKinectDKSharp.K4aFloat2T target_point2d)
            {
                var ____arg0 = source_point3d.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var ____arg3 = target_point2d.__Instance;
                var __arg3 = new global::System.IntPtr(&____arg3);
                var __ret = __Internal.Convert3dTo2d((__Instance + __PointerAdjustment), __arg0, source_camera, target_camera, __arg3);
                return __ret;
            }

            /// <summary>
/// <para>Transform a 2d pixel coordinate with an associated depth value of the source camera into a 2d pixel coordinate</para>
/// <para>of the target camera</para>
/// <para>Returns false if the point is invalid in the target coordinate system (and therefore target_point2d should not be</para>
/// <para>used)</para>
/// <para>Throws error if calibration contains invalid data.</para>
/// </summary>
/// <remarks>k4a_calibration_2d_to_2d</remarks>
            public bool Convert2dTo2d(global::AzureKinectDKSharp.K4aFloat2T source_point2d, float source_depth, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::AzureKinectDKSharp.K4aFloat2T target_point2d)
            {
                var ____arg0 = source_point2d.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                var ____arg4 = target_point2d.__Instance;
                var __arg4 = new global::System.IntPtr(&____arg4);
                var __ret = __Internal.Convert2dTo2d((__Instance + __PointerAdjustment), __arg0, source_depth, source_camera, target_camera, __arg4);
                return __ret;
            }

            /// <summary>
/// <para>Get the camera calibration for a device from a raw calibration blob.</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_calibration_get_from_raw</remarks>
            public static global::AzureKinectDKSharp.K4a.Calibration GetFromRaw(sbyte* raw_calibration, ulong raw_calibration_size, global::AzureKinectDKSharp.K4aDepthModeT depth_mode, global::AzureKinectDKSharp.K4aColorResolutionT color_resolution)
            {
                var __ret = new global::AzureKinectDKSharp.K4a.Calibration.__Internal();
                __Internal.GetFromRaw(new IntPtr(&__ret), raw_calibration, raw_calibration_size, depth_mode, color_resolution);
                return global::AzureKinectDKSharp.K4a.Calibration.__CreateInstance(__ret);
            }

            /// <summary>
/// <para>Get the camera calibration for a device from a raw calibration blob.</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_calibration_get_from_raw</remarks>
            public static global::AzureKinectDKSharp.K4a.Calibration GetFromRaw(byte* raw_calibration, ulong raw_calibration_size, global::AzureKinectDKSharp.K4aDepthModeT depth_mode, global::AzureKinectDKSharp.K4aColorResolutionT color_resolution)
            {
                var __ret = new global::AzureKinectDKSharp.K4a.Calibration.__Internal();
                __Internal.GetFromRaw_1(new IntPtr(&__ret), raw_calibration, raw_calibration_size, depth_mode, color_resolution);
                return global::AzureKinectDKSharp.K4a.Calibration.__CreateInstance(__ret);
            }
        }

        /// <summary>Wrapper for</summary>
/// <remarks>Wraps a handle for a transformation.</remarks>
        public unsafe partial class Transformation : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr m_handle;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0transformation@k4a@@QEAA@AEBU_k4a_calibration_t@@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::System.IntPtr calibration);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0transformation@k4a@@QEAA@PEAU_k4a_transformation_t@@@Z")]
                internal static extern global::System.IntPtr ctor_1(global::System.IntPtr __instance, global::System.IntPtr handle);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0transformation@k4a@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor_2(global::System.IntPtr __instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1transformation@k4a@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr __instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?destroy@transformation@k4a@@QEAAXXZ")]
                internal static extern void Destroy(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?depth_image_to_color_camera@transformation@k4a@@QEBAXAEBVimage@2@PEAV32@@Z")]
                internal static extern void DepthImageToColorCamera(global::System.IntPtr __instance, global::System.IntPtr depth_image, global::System.IntPtr transformed_depth_image);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?color_image_to_depth_camera@transformation@k4a@@QEBAXAEBVimage@2@0PEAV32@@Z")]
                internal static extern void ColorImageToDepthCamera(global::System.IntPtr __instance, global::System.IntPtr depth_image, global::System.IntPtr color_image, global::System.IntPtr transformed_color_image);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?depth_image_to_point_cloud@transformation@k4a@@QEBAXAEBVimage@2@W4k4a_calibration_type_t@@PEAV32@@Z")]
                internal static extern void DepthImageToPointCloud(global::System.IntPtr __instance, global::System.IntPtr depth_image, global::AzureKinectDKSharp.K4aCalibrationTypeT camera, global::System.IntPtr xyz_image);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4a.Transformation> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4a.Transformation>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::AzureKinectDKSharp.K4a.Transformation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Transformation(native.ToPointer(), skipVTables);
            }

            internal static global::AzureKinectDKSharp.K4a.Transformation __CreateInstance(global::AzureKinectDKSharp.K4a.Transformation.__Internal native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Transformation(native, skipVTables);
            }

            private static void* __CopyValue(global::AzureKinectDKSharp.K4a.Transformation.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Transformation.__Internal));
                *(global::AzureKinectDKSharp.K4a.Transformation.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Transformation(global::AzureKinectDKSharp.K4a.Transformation.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Transformation(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>Creates a transformation associated with calibration</summary>
/// <remarks>k4a_transformation_create</remarks>
            public Transformation(global::AzureKinectDKSharp.K4aCalibrationT calibration)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Transformation.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(calibration, null))
                    throw new global::System.ArgumentNullException("calibration", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = calibration.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>
/// <para>Creates a transformation from a k4a_transformation_t</para>
/// <para>Takes ownership of the handle, i.e. you should not call</para>
/// <para>k4a_transformation_destroy on the handle after giving</para>
/// <para>it to the transformation; the transformation will take care of that.</para>
/// </summary>
            public Transformation(global::AzureKinectDKSharp.K4aTransformationT handle)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Transformation.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
                __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            }

            public Transformation(global::AzureKinectDKSharp.K4a.Transformation _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Transformation.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::AzureKinectDKSharp.K4a.Transformation.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4a.Transformation.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::AzureKinectDKSharp.K4a.Transformation __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Invalidates this transformation</summary>
            public void Destroy()
            {
                __Internal.Destroy((__Instance + __PointerAdjustment));
            }

            /// <summary>
/// <para>Transforms the depth map into the geometry of the color camera.</para>
/// <para>Throws error on failure</para>
/// </summary>
/// <remarks>k4a_transformation_depth_image_to_color_camera</remarks>
            public void DepthImageToColorCamera(global::AzureKinectDKSharp.K4a.Image depth_image, global::AzureKinectDKSharp.K4a.Image transformed_depth_image)
            {
                if (ReferenceEquals(depth_image, null))
                    throw new global::System.ArgumentNullException("depth_image", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = depth_image.__Instance;
                var __arg1 = ReferenceEquals(transformed_depth_image, null) ? global::System.IntPtr.Zero : transformed_depth_image.__Instance;
                __Internal.DepthImageToColorCamera((__Instance + __PointerAdjustment), __arg0, __arg1);
            }

            /// <summary>
/// <para>Transforms the color image into the geometry of the depth camera.</para>
/// <para>Throws error on failure</para>
/// </summary>
/// <remarks>k4a_transformation_color_image_to_depth_camera</remarks>
            public void ColorImageToDepthCamera(global::AzureKinectDKSharp.K4a.Image depth_image, global::AzureKinectDKSharp.K4a.Image color_image, global::AzureKinectDKSharp.K4a.Image transformed_color_image)
            {
                if (ReferenceEquals(depth_image, null))
                    throw new global::System.ArgumentNullException("depth_image", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = depth_image.__Instance;
                if (ReferenceEquals(color_image, null))
                    throw new global::System.ArgumentNullException("color_image", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = color_image.__Instance;
                var __arg2 = ReferenceEquals(transformed_color_image, null) ? global::System.IntPtr.Zero : transformed_color_image.__Instance;
                __Internal.ColorImageToDepthCamera((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            }

            /// <summary>
/// <para>Transforms the depth image into 3 planar images representing X, Y and Z-coordinates of corresponding 3d points.</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_transformation_depth_image_to_point_cloud</remarks>
            public void DepthImageToPointCloud(global::AzureKinectDKSharp.K4a.Image depth_image, global::AzureKinectDKSharp.K4aCalibrationTypeT camera, global::AzureKinectDKSharp.K4a.Image xyz_image)
            {
                if (ReferenceEquals(depth_image, null))
                    throw new global::System.ArgumentNullException("depth_image", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = depth_image.__Instance;
                var __arg2 = ReferenceEquals(xyz_image, null) ? global::System.IntPtr.Zero : xyz_image.__Instance;
                __Internal.DepthImageToPointCloud((__Instance + __PointerAdjustment), __arg0, camera, __arg2);
            }

            public static implicit operator global::AzureKinectDKSharp.K4a.Transformation(global::AzureKinectDKSharp.K4aCalibrationT calibration)
            {
                return new global::AzureKinectDKSharp.K4a.Transformation(calibration);
            }

            public static implicit operator global::AzureKinectDKSharp.K4a.Transformation(global::AzureKinectDKSharp.K4aTransformationT handle)
            {
                return new global::AzureKinectDKSharp.K4a.Transformation(handle);
            }
        }

        /// <summary>Wrapper for</summary>
/// <remarks>Wraps a handle for a device.</remarks>
        public unsafe partial class Device : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr m_handle;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0device@k4a@@QEAA@PEAU_k4a_device_t@@@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::System.IntPtr handle);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0device@k4a@@QEAA@AEBV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr __instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1device@k4a@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr __instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??Bdevice@k4a@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?close@device@k4a@@QEAAXXZ")]
                internal static extern void Close(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?start_cameras@device@k4a@@QEAAXPEAU_k4a_device_configuration_t@@@Z")]
                internal static extern void StartCameras(global::System.IntPtr __instance, global::System.IntPtr configuration);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?stop_cameras@device@k4a@@QEAAXXZ")]
                internal static extern void StopCameras(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?start_imu@device@k4a@@QEAAXXZ")]
                internal static extern void StartImu(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?stop_imu@device@k4a@@QEAAXXZ")]
                internal static extern void StopImu(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_color_control@device@k4a@@QEBAXW4k4a_color_control_command_t@@PEAW4k4a_color_control_mode_t@@PEAH@Z")]
                internal static extern void GetColorControl(global::System.IntPtr __instance, global::AzureKinectDKSharp.K4aColorControlCommandT command, global::AzureKinectDKSharp.K4aColorControlModeT* mode, int* value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?set_color_control@device@k4a@@QEAAXW4k4a_color_control_command_t@@W4k4a_color_control_mode_t@@H@Z")]
                internal static extern void SetColorControl(global::System.IntPtr __instance, global::AzureKinectDKSharp.K4aColorControlCommandT command, global::AzureKinectDKSharp.K4aColorControlModeT mode, int value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_calibration@device@k4a@@QEBA?AUcalibration@2@W4k4a_depth_mode_t@@W4k4a_color_resolution_t@@@Z")]
                internal static extern void GetCalibration(global::System.IntPtr __instance, global::System.IntPtr @return, global::AzureKinectDKSharp.K4aDepthModeT depth_mode, global::AzureKinectDKSharp.K4aColorResolutionT color_resolution);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?open@device@k4a@@SA?AV12@I@Z")]
                internal static extern void Open(global::System.IntPtr @return, uint index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_serialnum@device@k4a@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
                internal static extern void GetSerialnum(global::System.IntPtr __instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?is_sync_in_connected@device@k4a@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSyncInConnected(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?is_sync_out_connected@device@k4a@@QEBA_NXZ")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSyncOutConnected(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_version@device@k4a@@QEBA?AU_k4a_hardware_version_t@@XZ")]
                internal static extern void GetVersion(global::System.IntPtr __instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?get_installed_count@device@k4a@@SAIXZ")]
                internal static extern uint GetInstalledCount();
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4a.Device> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4a.Device>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::AzureKinectDKSharp.K4a.Device __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Device(native.ToPointer(), skipVTables);
            }

            internal static global::AzureKinectDKSharp.K4a.Device __CreateInstance(global::AzureKinectDKSharp.K4a.Device.__Internal native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4a.Device(native, skipVTables);
            }

            private static void* __CopyValue(global::AzureKinectDKSharp.K4a.Device.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Device.__Internal));
                *(global::AzureKinectDKSharp.K4a.Device.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Device(global::AzureKinectDKSharp.K4a.Device.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Device(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
/// <para>Creates a device from a k4a_device_t</para>
/// <para>Takes ownership of the handle, i.e. you should not call</para>
/// <para>k4a_device_close on the handle after giving it to the</para>
/// <para>device; the device will take care of that.</para>
/// </summary>
            public Device(global::AzureKinectDKSharp.K4aDeviceT handle)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Device.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            }

            public Device(global::AzureKinectDKSharp.K4a.Device _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4a.Device.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::AzureKinectDKSharp.K4a.Device.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4a.Device.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::AzureKinectDKSharp.K4a.Device __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Returns true if the device is valid, false otherwise</summary>
            public static implicit operator bool(global::AzureKinectDKSharp.K4a.Device __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var __ret = __Internal.OperatorConversion(__arg0);
                return __ret;
            }

            /// <summary>Closes a k4a device.</summary>
/// <remarks>k4a_device_close</remarks>
            public void Close()
            {
                __Internal.Close((__Instance + __PointerAdjustment));
            }

            /// <summary>
/// <para>Starts the K4A device's cameras</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_device_start_cameras</remarks>
            public void StartCameras(global::AzureKinectDKSharp.K4aDeviceConfigurationT configuration)
            {
                var __arg0 = ReferenceEquals(configuration, null) ? global::System.IntPtr.Zero : configuration.__Instance;
                __Internal.StartCameras((__Instance + __PointerAdjustment), __arg0);
            }

            /// <summary>Stops the K4A device's cameras</summary>
/// <remarks>k4a_device_stop_cameras</remarks>
            public void StopCameras()
            {
                __Internal.StopCameras((__Instance + __PointerAdjustment));
            }

            /// <summary>
/// <para>Starts the K4A IMU</para>
/// <para>Throws error on failure</para>
/// </summary>
/// <remarks>k4a_device_start_imu</remarks>
            public void StartImu()
            {
                __Internal.StartImu((__Instance + __PointerAdjustment));
            }

            /// <summary>Stops the K4A IMU</summary>
/// <remarks>k4a_device_stop_imu</remarks>
            public void StopImu()
            {
                __Internal.StopImu((__Instance + __PointerAdjustment));
            }

            /// <summary>
/// <para>Get the K4A color sensor control value</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_device_get_color_control</remarks>
            public void GetColorControl(global::AzureKinectDKSharp.K4aColorControlCommandT command, global::AzureKinectDKSharp.K4aColorControlModeT* mode, ref int value)
            {
                fixed (int* __value2 = &value)
                {
                    var __arg2 = __value2;
                    __Internal.GetColorControl((__Instance + __PointerAdjustment), command, mode, __arg2);
                }
            }

            /// <summary>
/// <para>Set the K4A color sensor control value</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_device_set_color_control</remarks>
            public void SetColorControl(global::AzureKinectDKSharp.K4aColorControlCommandT command, global::AzureKinectDKSharp.K4aColorControlModeT mode, int value)
            {
                __Internal.SetColorControl((__Instance + __PointerAdjustment), command, mode, value);
            }

            /// <summary>
/// <para>Get the camera calibration for the entire K4A device, which is used for all transformation functions.</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_device_get_calibration</remarks>
            public global::AzureKinectDKSharp.K4a.Calibration GetCalibration(global::AzureKinectDKSharp.K4aDepthModeT depth_mode, global::AzureKinectDKSharp.K4aColorResolutionT color_resolution)
            {
                var __ret = new global::AzureKinectDKSharp.K4a.Calibration.__Internal();
                __Internal.GetCalibration((__Instance + __PointerAdjustment), new IntPtr(&__ret), depth_mode, color_resolution);
                return global::AzureKinectDKSharp.K4a.Calibration.__CreateInstance(__ret);
            }

            public static implicit operator global::AzureKinectDKSharp.K4a.Device(global::AzureKinectDKSharp.K4aDeviceT handle)
            {
                return new global::AzureKinectDKSharp.K4a.Device(handle);
            }

            /// <summary>
/// <para>Open a k4a device.</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_device_open</remarks>
            public static global::AzureKinectDKSharp.K4a.Device Open(uint index)
            {
                var __ret = new global::AzureKinectDKSharp.K4a.Device.__Internal();
                __Internal.Open(new IntPtr(&__ret), index);
                return global::AzureKinectDKSharp.K4a.Device.__CreateInstance(__ret);
            }

            /// <summary>
/// <para>Get the K4A device serial number</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_device_get_serialnum</remarks>
            public string Serialnum
            {
                get
                {
                    var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetSerialnum((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                    var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                    __basicStringRet0.Dispose(false);
                    return __stringRet0;
                }
            }

            /// <summary>
/// <para>Get the device jack status for the synchronization in connector</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_device_get_sync_jack</remarks>
            public bool IsSyncInConnected
            {
                get
                {
                    var __ret = __Internal.IsSyncInConnected((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>
/// <para>Get the device jack status for the synchronization out connector</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_device_get_sync_jack</remarks>
            public bool IsSyncOutConnected
            {
                get
                {
                    var __ret = __Internal.IsSyncOutConnected((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            /// <summary>
/// <para>Get the version numbers of the K4A subsystems' firmware</para>
/// <para>Throws error on failure.</para>
/// </summary>
/// <remarks>k4a_device_get_version</remarks>
            public global::AzureKinectDKSharp.K4aHardwareVersionT Version
            {
                get
                {
                    var __ret = new global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal();
                    __Internal.GetVersion((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                    return global::AzureKinectDKSharp.K4aHardwareVersionT.__CreateInstance(__ret);
                }
            }

            /// <summary>Gets the number of connected devices</summary>
/// <remarks>k4a_device_get_installed_count</remarks>
            public static uint InstalledCount
            {
                get
                {
                    var __ret = __Internal.GetInstalledCount();
                    return __ret;
                }
            }
        }

        namespace Internal
        {
        }
    }

    public unsafe partial class k4a
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_get_installed_count")]
            internal static extern uint K4aDeviceGetInstalledCount();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_set_debug_message_handler")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aSetDebugMessageHandler(global::System.IntPtr message_cb, global::System.IntPtr message_cb_context, global::AzureKinectDKSharp.K4aLogLevelT min_level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_open")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aDeviceOpen(uint index, global::System.IntPtr device_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_close")]
            internal static extern void K4aDeviceClose(global::System.IntPtr device_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_get_capture")]
            internal static extern global::AzureKinectDKSharp.K4aWaitResultT K4aDeviceGetCapture(global::System.IntPtr device_handle, global::System.IntPtr capture_handle, int timeout_in_ms);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_get_imu_sample")]
            internal static extern global::AzureKinectDKSharp.K4aWaitResultT K4aDeviceGetImuSample(global::System.IntPtr device_handle, global::System.IntPtr imu_sample, int timeout_in_ms);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_create")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aCaptureCreate(global::System.IntPtr capture_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_release")]
            internal static extern void K4aCaptureRelease(global::System.IntPtr capture_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_reference")]
            internal static extern void K4aCaptureReference(global::System.IntPtr capture_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_get_color_image")]
            internal static extern global::System.IntPtr K4aCaptureGetColorImage(global::System.IntPtr capture_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_get_depth_image")]
            internal static extern global::System.IntPtr K4aCaptureGetDepthImage(global::System.IntPtr capture_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_get_ir_image")]
            internal static extern global::System.IntPtr K4aCaptureGetIrImage(global::System.IntPtr capture_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_set_color_image")]
            internal static extern void K4aCaptureSetColorImage(global::System.IntPtr capture_handle, global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_set_depth_image")]
            internal static extern void K4aCaptureSetDepthImage(global::System.IntPtr capture_handle, global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_set_ir_image")]
            internal static extern void K4aCaptureSetIrImage(global::System.IntPtr capture_handle, global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_set_temperature_c")]
            internal static extern void K4aCaptureSetTemperatureC(global::System.IntPtr capture_handle, float temperature_c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_capture_get_temperature_c")]
            internal static extern float K4aCaptureGetTemperatureC(global::System.IntPtr capture_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_create")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aImageCreate(global::AzureKinectDKSharp.K4aImageFormatT format, int width_pixels, int height_pixels, int stride_bytes, global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_create_from_buffer")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aImageCreateFromBuffer(global::AzureKinectDKSharp.K4aImageFormatT format, int width_pixels, int height_pixels, int stride_bytes, byte* buffer, ulong buffer_size, global::System.IntPtr buffer_release_cb, global::System.IntPtr buffer_release_cb_context, global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_get_buffer")]
            internal static extern byte* K4aImageGetBuffer(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_get_size")]
            internal static extern ulong K4aImageGetSize(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_get_format")]
            internal static extern global::AzureKinectDKSharp.K4aImageFormatT K4aImageGetFormat(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_get_width_pixels")]
            internal static extern int K4aImageGetWidthPixels(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_get_height_pixels")]
            internal static extern int K4aImageGetHeightPixels(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_get_stride_bytes")]
            internal static extern int K4aImageGetStrideBytes(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_get_timestamp_usec")]
            internal static extern ulong K4aImageGetTimestampUsec(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_get_exposure_usec")]
            internal static extern ulong K4aImageGetExposureUsec(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_get_white_balance")]
            internal static extern uint K4aImageGetWhiteBalance(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_get_iso_speed")]
            internal static extern uint K4aImageGetIsoSpeed(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_set_timestamp_usec")]
            internal static extern void K4aImageSetTimestampUsec(global::System.IntPtr image_handle, ulong timestamp_usec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_set_exposure_time_usec")]
            internal static extern void K4aImageSetExposureTimeUsec(global::System.IntPtr image_handle, ulong exposure_usec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_set_white_balance")]
            internal static extern void K4aImageSetWhiteBalance(global::System.IntPtr image_handle, uint white_balance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_set_iso_speed")]
            internal static extern void K4aImageSetIsoSpeed(global::System.IntPtr image_handle, uint iso_speed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_reference")]
            internal static extern void K4aImageReference(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_image_release")]
            internal static extern void K4aImageRelease(global::System.IntPtr image_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_start_cameras")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aDeviceStartCameras(global::System.IntPtr device_handle, global::System.IntPtr config);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_stop_cameras")]
            internal static extern void K4aDeviceStopCameras(global::System.IntPtr device_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_start_imu")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aDeviceStartImu(global::System.IntPtr device_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_stop_imu")]
            internal static extern void K4aDeviceStopImu(global::System.IntPtr device_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_get_serialnum")]
            internal static extern global::AzureKinectDKSharp.K4aBufferResultT K4aDeviceGetSerialnum(global::System.IntPtr device_handle, sbyte* serial_number, ulong* serial_number_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_get_version")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aDeviceGetVersion(global::System.IntPtr device_handle, global::System.IntPtr version);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_get_color_control_capabilities")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aDeviceGetColorControlCapabilities(global::System.IntPtr device_handle, global::AzureKinectDKSharp.K4aColorControlCommandT command, bool* supports_auto, int* min_value, int* max_value, int* step_value, int* default_value, global::AzureKinectDKSharp.K4aColorControlModeT* default_mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_get_color_control")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aDeviceGetColorControl(global::System.IntPtr device_handle, global::AzureKinectDKSharp.K4aColorControlCommandT command, global::AzureKinectDKSharp.K4aColorControlModeT* mode, int* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_set_color_control")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aDeviceSetColorControl(global::System.IntPtr device_handle, global::AzureKinectDKSharp.K4aColorControlCommandT command, global::AzureKinectDKSharp.K4aColorControlModeT mode, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_get_raw_calibration")]
            internal static extern global::AzureKinectDKSharp.K4aBufferResultT K4aDeviceGetRawCalibration(global::System.IntPtr device_handle, byte* data, ulong* data_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_get_calibration")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aDeviceGetCalibration(global::System.IntPtr device_handle, global::AzureKinectDKSharp.K4aDepthModeT depth_mode, global::AzureKinectDKSharp.K4aColorResolutionT color_resolution, global::System.IntPtr calibration);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_device_get_sync_jack")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aDeviceGetSyncJack(global::System.IntPtr device_handle, bool* sync_in_jack_connected, bool* sync_out_jack_connected);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_calibration_get_from_raw")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aCalibrationGetFromRaw(sbyte* raw_calibration, ulong raw_calibration_size, global::AzureKinectDKSharp.K4aDepthModeT depth_mode, global::AzureKinectDKSharp.K4aColorResolutionT color_resolution, global::System.IntPtr calibration);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_calibration_3d_to_3d")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aCalibration3dTo3d(global::System.IntPtr calibration, global::System.IntPtr source_point3d_mm, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::System.IntPtr target_point3d_mm);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_calibration_2d_to_3d")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aCalibration2dTo3d(global::System.IntPtr calibration, global::System.IntPtr source_point2d, float source_depth_mm, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::System.IntPtr target_point3d_mm, int* valid);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_calibration_3d_to_2d")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aCalibration3dTo2d(global::System.IntPtr calibration, global::System.IntPtr source_point3d_mm, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::System.IntPtr target_point2d, int* valid);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_calibration_2d_to_2d")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aCalibration2dTo2d(global::System.IntPtr calibration, global::System.IntPtr source_point2d, float source_depth_mm, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::System.IntPtr target_point2d, int* valid);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_transformation_create")]
            internal static extern global::System.IntPtr K4aTransformationCreate(global::System.IntPtr calibration);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_transformation_destroy")]
            internal static extern void K4aTransformationDestroy(global::System.IntPtr transformation_handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_transformation_depth_image_to_color_camera")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aTransformationDepthImageToColorCamera(global::System.IntPtr transformation_handle, global::System.IntPtr depth_image, global::System.IntPtr transformed_depth_image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_transformation_color_image_to_depth_camera")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aTransformationColorImageToDepthCamera(global::System.IntPtr transformation_handle, global::System.IntPtr depth_image, global::System.IntPtr color_image, global::System.IntPtr transformed_color_image);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("k4a", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="k4a_transformation_depth_image_to_point_cloud")]
            internal static extern global::AzureKinectDKSharp.K4aResultT K4aTransformationDepthImageToPointCloud(global::System.IntPtr transformation_handle, global::System.IntPtr depth_image, global::AzureKinectDKSharp.K4aCalibrationTypeT camera, global::System.IntPtr xyz_image);
        }

        /// <summary>Gets the number of connected devices</summary>
/// <remarks>
/// <para>Number of sensors connected to the PC.</para>
/// <para>This API counts the number of Azure Kinect devices connected to the host PC.</para>
/// </remarks>
        public static uint K4aDeviceGetInstalledCount()
        {
            var __ret = __Internal.K4aDeviceGetInstalledCount();
            return __ret;
        }

        /// <summary>Sets and clears the callback function to recieve debug messages from the Azure Kinect device.</summary>
/// <param name="message_cb">The callback function to recieve messages from. Set to NULL to unregister the callback function.</param>
/// <param name="message_cb_context">The callback functions context.</param>
/// <param name="min_level">The least critical error the user wants to be notified about.</param>
/// <returns>
/// <para>::K4A_RESULT_SUCCEEDED if the callback function was set or cleared successfully. ::K4A_RESULT_FAILED if an</para>
/// <para>error is encountered or the callback function has already been set.</para>
/// </returns>
/// <remarks>
/// <para>Call this function to set or clear the callback function that is used to deliver debug messages to the caller. This</para>
/// <para>callback may be called concurrently, it is up to the implementation of the callback function to ensure the</para>
/// <para>parallelization is handled.</para>
/// <para>Clearing the callback function will block until all pending calls to the callback function have completed.</para>
/// <para>To updatecan be called with the same valueand by</para>
/// <para>specifying a new</para>
/// <para>Logging provided via this API is independent of the logging controlled by the environmental variable controlsandHowever there is a slight change in</para>
/// <para>default behavior when using this function. By default, whenhas not been used to</para>
/// <para>register a message callback, the default for environmental variable controls is to send debug messages as if</para>
/// <para>K4A_ENABLE_LOG_TO_STDOUT=1 were set. Ifregisters a callback function before</para>
/// <para>k4a_device_open() is called, then the default for environmental controls is as if K4A_ENABLE_LOG_TO_STDOUT=0 was</para>
/// <para>specified. Physically specifying the environmental control will override the default.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aSetDebugMessageHandler(global::AzureKinectDKSharp.K4aLoggingMessageCbT message_cb, global::System.IntPtr message_cb_context, global::AzureKinectDKSharp.K4aLogLevelT min_level)
        {
            var __arg0 = message_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(message_cb);
            var __ret = __Internal.K4aSetDebugMessageHandler(__arg0, message_cb_context, min_level);
            return __ret;
        }

        /// <summary>Open an Azure Kinect device.</summary>
/// <param name="index">The index of the device to open, starting with 0. Optionally pass in #K4A_DEVICE_DEFAULT.</param>
/// <param name="device_handle">Output parameter which on success will return a handle to the device.</param>
/// <returns>::K4A_RESULT_SUCCEEDED if the device was opened successfully.</returns>
/// <remarks>
/// <para>If successful, k4a_device_open() will return a device handle in the device_handle parameter.</para>
/// <para>This handle grants exclusive access to the device and may be used in the other Azure Kinect API calls.</para>
/// <para>When done with the device, close the handle with k4a_device_close()</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aDeviceOpen(uint index, global::AzureKinectDKSharp.K4aDeviceT device_handle)
        {
            var __arg1 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            var __ret = __Internal.K4aDeviceOpen(index, __arg1);
            return __ret;
        }

        /// <summary>Closes an Azure Kinect device.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <remarks>
/// <para>Once closed, the handle is no longer valid.</para>
/// <para>Before closing the handle to the device, ensure that all</para>
/// <para>k4a_capture_release().</para>
/// </remarks>
        public static void K4aDeviceClose(global::AzureKinectDKSharp.K4aDeviceT device_handle)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            __Internal.K4aDeviceClose(__arg0);
        }

        /// <summary>Reads a sensor capture.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <param name="capture_handle">
/// <para>If successful this contains a handle to a capture object. Caller must call k4a_capture_release() when its done using</para>
/// <para>this capture.</para>
/// </param>
/// <param name="timeout_in_ms">
/// <para>Specifies the time in milliseconds the function should block waiting for the capture. If set to 0, the function will</para>
/// <para>return without blocking. Passing a value of #K4A_WAIT_INFINITE will block indefinitely until data is available, the</para>
/// <para>device is disconnected, or another error occurs.</para>
/// </param>
/// <remarks>
/// <para>::K4A_WAIT_RESULT_SUCCEEDED if a capture is returned. If a capture is not available before the timeout elapses, the</para>
/// <para>function will return ::K4A_WAIT_RESULT_TIMEOUT. All other failures will return ::K4A_WAIT_RESULT_FAILED.</para>
/// <para>Gets the next capture in the streamed sequence of captures from the camera. If a new capture is not currently</para>
/// <para>available, this function will block until the timeout is reached. The SDK will buffer at least two captures worth</para>
/// <para>of data before dropping the oldest capture. Callers needing to capture all data need to ensure they read the data as</para>
/// <para>fast as the data is being produced on average.</para>
/// <para>Upon successfully reading a capture this function will return success and populateIf a capture is not available in the configuredthen the API will return ::K4A_WAIT_RESULT_TIMEOUT.</para>
/// <para>If the call is successful and a capture is returned, callers must call k4a_capture_release() to return the allocated</para>
/// <para>memory.</para>
/// <para>This function needs to be called while the device is in a running state;</para>
/// <para>after k4a_device_start_cameras() is called and before k4a_device_stop_cameras() is called.</para>
/// <para>This function returns an error when an internal problem is encountered; such as loss of the USB connection, inability</para>
/// <para>to allocate enough memory, and other unexpected issues. Any error returned by this function signals the end of</para>
/// <para>streaming data, and caller should stop the stream using k4a_device_stop_cameras().</para>
/// <para>If this function is waiting for data (non-zero timeout) when k4a_device_stop_cameras() or k4a_device_close() is</para>
/// <para>called on another thread, this function will return an error.</para>
/// <para>::K4A_WAIT_RESULT_SUCCEEDED if a capture is returned. If a capture is not available before the timeout</para>
/// <para>elapses, the function will return ::K4A_WAIT_RESULT_TIMEOUT. All other failures will return ::K4A_WAIT_RESULT_FAILED.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aWaitResultT K4aDeviceGetCapture(global::AzureKinectDKSharp.K4aDeviceT device_handle, global::AzureKinectDKSharp.K4aCaptureT capture_handle, int timeout_in_ms)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            var __arg1 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            var __ret = __Internal.K4aDeviceGetCapture(__arg0, __arg1, timeout_in_ms);
            return __ret;
        }

        /// <summary>Reads an IMU sample.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <param name="imu_sample">Pointer to the location for the API to write the IMU sample.</param>
/// <param name="timeout_in_ms">
/// <para>Specifies the time in milliseconds the function should block waiting for the sample. If set to 0, the function will</para>
/// <para>return without blocking. Passing a value of #K4A_WAIT_INFINITE will block indefinitely until data is available, the</para>
/// <para>device is disconnected, or another error occurs.</para>
/// </param>
/// <remarks>
/// <para>::K4A_WAIT_RESULT_SUCCEEDED if a sample is returned. If a sample is not available before the timeout elapses, the</para>
/// <para>function will return ::K4A_WAIT_RESULT_TIMEOUT. All other failures will return ::K4A_WAIT_RESULT_FAILED.</para>
/// <para>Gets the next sample in the streamed sequence of IMU samples from the device. If a new sample is not currently</para>
/// <para>available, this function will block until the timeout is reached. The API will buffer at least two camera capture</para>
/// <para>intervals worth of samples before dropping the oldest sample. Callers needing to capture all data need to ensure they</para>
/// <para>read the data as fast as the data is being produced on average.</para>
/// <para>Upon successfully reading a sample this function will return success and populateIf a sample is not available in the configuredthen the API will return ::K4A_WAIT_RESULT_TIMEOUT.</para>
/// <para>This function needs to be called while the device is in a running state;</para>
/// <para>after k4a_device_start_imu() is called and before k4a_device_stop_imu() is called.</para>
/// <para>This function returns an error when an internal problem is encountered; such as loss of the USB connection, inability</para>
/// <para>to allocate enough memory, and other unexpected issues. Any error returned by this function signals the end of</para>
/// <para>streaming data, and caller should stop the stream using k4a_device_stop_imu().</para>
/// <para>If this function is waiting for data (non-zero timeout) when k4a_device_stop_imu() or k4a_device_close() is</para>
/// <para>called on another thread, this function will return an error.</para>
/// <para>The memory the IMU sample is written to is allocated and owned by the caller, so there is no need to call an Azure</para>
/// <para>Kinect API to free or release the sample.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aWaitResultT K4aDeviceGetImuSample(global::AzureKinectDKSharp.K4aDeviceT device_handle, global::AzureKinectDKSharp.K4aImuSampleT imu_sample, int timeout_in_ms)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            var __arg1 = ReferenceEquals(imu_sample, null) ? global::System.IntPtr.Zero : imu_sample.__Instance;
            var __ret = __Internal.K4aDeviceGetImuSample(__arg0, __arg1, timeout_in_ms);
            return __ret;
        }

        /// <summary>Create an empty capture object.</summary>
/// <param name="capture_handle">Pointer to a location to store the handle.</param>
/// <remarks>
/// <para>Call this function to create a</para>
/// <para>The new capture is created with a reference count of 1.</para>
/// <para>Returns #K4A_RESULT_SUCCEEDED on success. Errors are indicated with #K4A_RESULT_FAILED and error specific data can be</para>
/// <para>found in the log.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aCaptureCreate(global::AzureKinectDKSharp.K4aCaptureT capture_handle)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            var __ret = __Internal.K4aCaptureCreate(__arg0);
            return __ret;
        }

        /// <summary>Release a capture.</summary>
/// <param name="capture_handle">Capture to release.</param>
/// <remarks>Call this function when finished using the capture.</remarks>
        public static void K4aCaptureRelease(global::AzureKinectDKSharp.K4aCaptureT capture_handle)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            __Internal.K4aCaptureRelease(__arg0);
        }

        /// <summary>Add a reference to a capture.</summary>
/// <param name="capture_handle">Capture to add a reference to.</param>
/// <remarks>
/// <para>Call this function to add an additional reference to a capture. This reference must be removed with</para>
/// <para>k4a_capture_release().</para>
/// </remarks>
        public static void K4aCaptureReference(global::AzureKinectDKSharp.K4aCaptureT capture_handle)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            __Internal.K4aCaptureReference(__arg0);
        }

        /// <summary>Get the color image associated with the given capture.</summary>
/// <param name="capture_handle">Capture handle containing the image.</param>
/// <remarks>
/// <para>Call this function to access the color image part of this capture. Release the</para>
/// <para>k4a_image_release();</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aImageT K4aCaptureGetColorImage(global::AzureKinectDKSharp.K4aCaptureT capture_handle)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            var __ret = __Internal.K4aCaptureGetColorImage(__arg0);
            global::AzureKinectDKSharp.K4aImageT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AzureKinectDKSharp.K4aImageT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AzureKinectDKSharp.K4aImageT) global::AzureKinectDKSharp.K4aImageT.NativeToManagedMap[__ret];
            else __result0 = global::AzureKinectDKSharp.K4aImageT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the depth image associated with the given capture.</summary>
/// <param name="capture_handle">Capture handle containing the image.</param>
/// <remarks>
/// <para>Call this function to access the depth image part of this capture. Release the</para>
/// <para>k4a_image_release();</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aImageT K4aCaptureGetDepthImage(global::AzureKinectDKSharp.K4aCaptureT capture_handle)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            var __ret = __Internal.K4aCaptureGetDepthImage(__arg0);
            global::AzureKinectDKSharp.K4aImageT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AzureKinectDKSharp.K4aImageT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AzureKinectDKSharp.K4aImageT) global::AzureKinectDKSharp.K4aImageT.NativeToManagedMap[__ret];
            else __result0 = global::AzureKinectDKSharp.K4aImageT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the IR image associated with the given capture.</summary>
/// <param name="capture_handle">Capture handle containing the image.</param>
/// <remarks>
/// <para>Call this function to access the IR image part of this capture. Release the</para>
/// <para>k4a_image_release();</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aImageT K4aCaptureGetIrImage(global::AzureKinectDKSharp.K4aCaptureT capture_handle)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            var __ret = __Internal.K4aCaptureGetIrImage(__arg0);
            global::AzureKinectDKSharp.K4aImageT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AzureKinectDKSharp.K4aImageT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AzureKinectDKSharp.K4aImageT) global::AzureKinectDKSharp.K4aImageT.NativeToManagedMap[__ret];
            else __result0 = global::AzureKinectDKSharp.K4aImageT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set or add a color image to the associated capture.</summary>
/// <param name="capture_handle">Capture handle to hold the image.</param>
/// <param name="image_handle">Image handle containing the image.</param>
/// <remarks>
/// <para>When a</para>
/// <para>to the</para>
/// <para>If there is already a color image contained in the capture, the existing image will be dereferenced and replaced with</para>
/// <para>the new image.</para>
/// <para>To remove a color image to the capture without adding a new image, this function can be called with a NULL</para>
/// <para>image_handle.</para>
/// <para>Any</para>
/// <para>the</para>
/// </remarks>
        public static void K4aCaptureSetColorImage(global::AzureKinectDKSharp.K4aCaptureT capture_handle, global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            var __arg1 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            __Internal.K4aCaptureSetColorImage(__arg0, __arg1);
        }

        /// <summary>Set or add a depth image to the associated capture.</summary>
/// <param name="capture_handle">Capture handle to hold the image.</param>
/// <param name="image_handle">Image handle containing the image.</param>
/// <remarks>
/// <para>When a</para>
/// <para>to the</para>
/// <para>If there is already an image depth image contained in the capture, the existing image will be dereferenced and</para>
/// <para>replaced with the new image.</para>
/// <para>To remove a depth image to the capture without adding a new image, this function can be called with a NULL</para>
/// <para>image_handle.</para>
/// <para>Any</para>
/// <para>the</para>
/// </remarks>
        public static void K4aCaptureSetDepthImage(global::AzureKinectDKSharp.K4aCaptureT capture_handle, global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            var __arg1 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            __Internal.K4aCaptureSetDepthImage(__arg0, __arg1);
        }

        /// <summary>Set or add an IR image to the associated capture.</summary>
/// <param name="capture_handle">Capture handle to hold the image.</param>
/// <param name="image_handle">Image handle containing the image.</param>
/// <remarks>
/// <para>When a</para>
/// <para>to the</para>
/// <para>If there is already an IR image contained in the capture, the existing image will be dereferenced and replaced with</para>
/// <para>the new image.</para>
/// <para>To remove a IR image to the capture without adding a new image, this function can be called with a NULL image_handle.</para>
/// <para>Any</para>
/// <para>the</para>
/// </remarks>
        public static void K4aCaptureSetIrImage(global::AzureKinectDKSharp.K4aCaptureT capture_handle, global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            var __arg1 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            __Internal.K4aCaptureSetIrImage(__arg0, __arg1);
        }

        /// <summary>Set the temperature associated with the capture.</summary>
/// <param name="capture_handle">Capture handle to set the temperature on.</param>
/// <param name="temperature_c">Temperature in Celsius to store.</param>
        public static void K4aCaptureSetTemperatureC(global::AzureKinectDKSharp.K4aCaptureT capture_handle, float temperature_c)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            __Internal.K4aCaptureSetTemperatureC(__arg0, temperature_c);
        }

        /// <summary>Get the temperature associated with the capture.</summary>
/// <param name="capture_handle">Capture handle to retrieve the temperature from.</param>
/// <returns>
/// <para>This function returns the temperature of the device at the time of the capture in Celsius. If</para>
/// <para>the temperature is unavailable, the function will return NAN.</para>
/// </returns>
        public static float K4aCaptureGetTemperatureC(global::AzureKinectDKSharp.K4aCaptureT capture_handle)
        {
            var __arg0 = ReferenceEquals(capture_handle, null) ? global::System.IntPtr.Zero : capture_handle.__Instance;
            var __ret = __Internal.K4aCaptureGetTemperatureC(__arg0);
            return __ret;
        }

        /// <summary>Create an image.</summary>
/// <param name="image_handle">Pointer to store image handle in.</param>
/// <param name="height_pixels">Height in pixels.</param>
/// <param name="width_pixels">Width in pixels.</param>
/// <param name="stride_bytes">The number of bytes per horizontal line of the image.</param>
/// <param name="format">The format of the image that will be stored in this image container.</param>
/// <remarks>
/// <para>When finished using the created image, release it with k4a_image_release.</para>
/// <para>This function is used to create images of formats that have consistent stride. The function is not suitable for</para>
/// <para>compressed formats that may not be represented by the same number of bytes per line.</para>
/// <para>The function will allocate an image buffer of size*</para>
/// <para>To create an image object without the API allocating memory, or to represent an image that has a non-deterministic</para>
/// <para>stride, use k4a_image_create_from_buffer().</para>
/// <para>The</para>
/// <para>Returns #K4A_RESULT_SUCCEEDED on success. Errors are indicated with #K4A_RESULT_FAILED.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aImageCreate(global::AzureKinectDKSharp.K4aImageFormatT format, int width_pixels, int height_pixels, int stride_bytes, global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg4 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageCreate(format, width_pixels, height_pixels, stride_bytes, __arg4);
            return __ret;
        }

        /// <summary>Create an image from a pre-allocated buffer.</summary>
/// <param name="format">The format of the image that will be stored in this image container.</param>
/// <param name="width_pixels">Width in pixels.</param>
/// <param name="height_pixels">Height in pixels.</param>
/// <param name="image_handle">Pointer to store image handle in.</param>
/// <param name="stride_bytes">The number of bytes per horizontal line of the image.</param>
/// <param name="buffer">Pointer to a pre-allocated image buffer.</param>
/// <param name="buffer_release_cb_context">
/// <para>Context for the buffer free function. This value will be called as a parameter towhen</para>
/// <para>the callback is invoked.</para>
/// </param>
/// <param name="buffer_size">Size in bytes of the pre-allocated image buffer.</param>
/// <param name="buffer_release_cb">
/// <para>Callback to the buffer free function, called when all references to the buffer have been released. This parameter is</para>
/// <para>optional.</para>
/// </param>
/// <remarks>
/// <para>The</para>
/// <para>This function creates a</para>
/// <para>the providedcallback function is called so that the memory can be released. If this function</para>
/// <para>fails, the API will not use the memory provided inand the API will not call</para>
/// <para>Release the reference on this function with k4a_image_release().</para>
/// <para>Returns #K4A_RESULT_SUCCEEDED on success. Errors are indicated with #K4A_RESULT_FAILED and error specific data can be</para>
/// <para>found in the log.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aImageCreateFromBuffer(global::AzureKinectDKSharp.K4aImageFormatT format, int width_pixels, int height_pixels, int stride_bytes, byte* buffer, ulong buffer_size, global::AzureKinectDKSharp.K4aMemoryDestroyCbT buffer_release_cb, global::System.IntPtr buffer_release_cb_context, global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg6 = buffer_release_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(buffer_release_cb);
            var __arg8 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageCreateFromBuffer(format, width_pixels, height_pixels, stride_bytes, buffer, buffer_size, __arg6, buffer_release_cb_context, __arg8);
            return __ret;
        }

        /// <summary>Get the image buffer.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>Use this buffer to access the raw image data.</para>
/// <para>The function will return NULL if there is an error, and will normally return a pointer to the image buffer.</para>
/// <para>Since all</para>
/// <para>is invalid.</para>
/// </remarks>
        public static byte* K4aImageGetBuffer(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageGetBuffer(__arg0);
            return __ret;
        }

        /// <summary>Get the image buffer size.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>Use this function to know what the size of the image buffer is returned by k4a_image_get_buffer().</para>
/// <para>The function will return 0 if there is an error, and will normally return the image size.</para>
/// <para>Since all</para>
/// <para>is invalid.</para>
/// </remarks>
        public static ulong K4aImageGetSize(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageGetSize(__arg0);
            return __ret;
        }

        /// <summary>Get the format of the image.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>Use this function to determine the format of the image buffer.</para>
/// <para>This function is not expected to fail, all</para>
/// <para>is invalid, the function will return ::K4A_IMAGE_FORMAT_CUSTOM.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aImageFormatT K4aImageGetFormat(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageGetFormat(__arg0);
            return __ret;
        }

        /// <summary>Get the image width in pixels.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>This function is not expected to fail, all</para>
/// <para>image_handle is invalid, the function will return 0.</para>
/// </remarks>
        public static int K4aImageGetWidthPixels(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageGetWidthPixels(__arg0);
            return __ret;
        }

        /// <summary>Get the image height in pixels.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>This function is not expected to fail, all</para>
/// <para>image_handle is invalid, the function will return 0.</para>
/// </remarks>
        public static int K4aImageGetHeightPixels(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageGetHeightPixels(__arg0);
            return __ret;
        }

        /// <summary>Get the image stride in bytes.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>This function is not expected to fail, all</para>
/// <para>is invalid, or the image's format does not have a stride, the function will return 0.</para>
/// </remarks>
        public static int K4aImageGetStrideBytes(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageGetStrideBytes(__arg0);
            return __ret;
        }

        /// <summary>Get the image timestamp in microseconds</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>Returns the timestamp of the image. Timestamps are recorded by the device and represent the mid-point of exposure.</para>
/// <para>They may be used for relative comparison, but their absolute value has no defined meaning.</para>
/// <para>If theis invalid or if no timestamp was set for the image,</para>
/// <para>this function will return 0. It is also possible for 0 to be a valid timestamp originating from the beginning</para>
/// <para>of a recording or the start of streaming.</para>
/// </remarks>
        public static ulong K4aImageGetTimestampUsec(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageGetTimestampUsec(__arg0);
            return __ret;
        }

        /// <summary>Get the image exposure in microseconds.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>Returns an exposure time in microseconds. This is only supported on color image formats.</para>
/// <para>If theis invalid, or no exposure was set on the image, the function will return 0. Otherwise,</para>
/// <para>it will return the image exposure time in microseconds.</para>
/// </remarks>
        public static ulong K4aImageGetExposureUsec(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageGetExposureUsec(__arg0);
            return __ret;
        }

        /// <summary>Get the image white balance.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>Returns the image's white balance. This function is only valid for color captures, and not for depth or IR captures.</para>
/// <para>Returns the image white balance in Kelvin. Ifis invalid, or the white balance was not set or</para>
/// <para>not applicable to the image, the function will return 0.</para>
/// </remarks>
        public static uint K4aImageGetWhiteBalance(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageGetWhiteBalance(__arg0);
            return __ret;
        }

        /// <summary>Get the image ISO speed.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>This function is only valid for color captures, and not for depth  or IR captures.</para>
/// <para>Returns the ISO speed of the image. 0 indicates the ISO speed was not available or an error occurred.</para>
/// </remarks>
        public static uint K4aImageGetIsoSpeed(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            var __ret = __Internal.K4aImageGetIsoSpeed(__arg0);
            return __ret;
        }

        /// <summary>Set the time stamp, in microseconds, of the image.</summary>
/// <param name="image_handle">Handle of the image to set the timestamp on.</param>
/// <param name="timestamp_usec">Timestamp of the image in microseconds.</param>
/// <remarks>
/// <para>Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a</para>
/// <para>Set a timestamp of 0 to indicate that the timestamp is not valid.</para>
/// </remarks>
        public static void K4aImageSetTimestampUsec(global::AzureKinectDKSharp.K4aImageT image_handle, ulong timestamp_usec)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            __Internal.K4aImageSetTimestampUsec(__arg0, timestamp_usec);
        }

        /// <summary>Set the exposure time, in microseconds, of the image.</summary>
/// <param name="image_handle">Handle of the image to set the exposure time on.</param>
/// <param name="exposure_usec">Exposure time of the image in microseconds.</param>
/// <remarks>
/// <para>Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a</para>
/// <para>exposure time.</para>
/// </remarks>
        public static void K4aImageSetExposureTimeUsec(global::AzureKinectDKSharp.K4aImageT image_handle, ulong exposure_usec)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            __Internal.K4aImageSetExposureTimeUsec(__arg0, exposure_usec);
        }

        /// <summary>Set the white balance of the image.</summary>
/// <param name="image_handle">Handle of the image to set the white balance on.</param>
/// <param name="white_balance">White balance of the image in degrees Kelvin.</param>
/// <remarks>
/// <para>Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a</para>
/// <para>and not expected on depth or IR images.</para>
/// </remarks>
        public static void K4aImageSetWhiteBalance(global::AzureKinectDKSharp.K4aImageT image_handle, uint white_balance)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            __Internal.K4aImageSetWhiteBalance(__arg0, white_balance);
        }

        /// <summary>Set the ISO speed of the image.</summary>
/// <param name="image_handle">Handle of the image to set the ISO speed on.</param>
/// <param name="iso_speed">ISO speed of the image.</param>
/// <remarks>Use this function in conjunction with k4a_image_create() or k4a_image_create_from_buffer() to construct a</remarks>
        public static void K4aImageSetIsoSpeed(global::AzureKinectDKSharp.K4aImageT image_handle, uint iso_speed)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            __Internal.K4aImageSetIsoSpeed(__arg0, iso_speed);
        }

        /// <summary>Add a reference to the k4a_image_t.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>References manage the lifetime of the object. When the references reach zero the object is destroyed. A caller must</para>
/// <para>not access the object after its reference is released.</para>
/// </remarks>
        public static void K4aImageReference(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            __Internal.K4aImageReference(__arg0);
        }

        /// <summary>Remove a reference from the k4a_image_t.</summary>
/// <param name="image_handle">Handle of the image for which the get operation is performed on.</param>
/// <remarks>
/// <para>References manage the lifetime of the object. When the references reach zero the object is destroyed. A caller must</para>
/// <para>not access the object after its reference is released.</para>
/// </remarks>
        public static void K4aImageRelease(global::AzureKinectDKSharp.K4aImageT image_handle)
        {
            var __arg0 = ReferenceEquals(image_handle, null) ? global::System.IntPtr.Zero : image_handle.__Instance;
            __Internal.K4aImageRelease(__arg0);
        }

        /// <summary>Starts color and depth camera capture.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <param name="config">The configuration we want to run the device in. This can be initialized with ::K4A_DEVICE_CONFIG_INIT_DISABLE_ALL.</param>
/// <remarks>
/// <para>::K4A_RESULT_SUCCEEDED is returned on success.</para>
/// <para>Individual sensors configured to run will now start to stream captured data.</para>
/// <para>It is not valid to call k4a_device_start_cameras() a second time on the same</para>
/// <para>k4a_device_stop_cameras() has been called.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aDeviceStartCameras(global::AzureKinectDKSharp.K4aDeviceT device_handle, global::AzureKinectDKSharp.K4aDeviceConfigurationT config)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            var __arg1 = ReferenceEquals(config, null) ? global::System.IntPtr.Zero : config.__Instance;
            var __ret = __Internal.K4aDeviceStartCameras(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Stops the color and depth camera capture.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <remarks>
/// <para>The streaming of individual sensors stops as a result of this call. Once called, k4a_device_start_cameras() may</para>
/// <para>be called again to resume sensor streaming.</para>
/// <para>This function may be called while another thread is blocking in k4a_device_get_capture().</para>
/// <para>Calling this function while another thread is in that function will result in that function returning a failure.</para>
/// </remarks>
        public static void K4aDeviceStopCameras(global::AzureKinectDKSharp.K4aDeviceT device_handle)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            __Internal.K4aDeviceStopCameras(__arg0);
        }

        /// <summary>Starts the IMU sample stream.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <remarks>
/// <para>::K4A_RESULT_SUCCEEDED is returned on success. ::K4A_RESULT_FAILED if the sensor is already running or a failure is</para>
/// <para>encountered</para>
/// <para>Call this API to start streaming IMU data. It is not valid to call this function a second time on the same</para>
/// <para>This function is dependent on the state of the cameras. The color or depth camera must be started before the IMU.</para>
/// <para>::K4A_RESULT_FAILED will be returned if one of the cameras is not running.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aDeviceStartImu(global::AzureKinectDKSharp.K4aDeviceT device_handle)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            var __ret = __Internal.K4aDeviceStartImu(__arg0);
            return __ret;
        }

        /// <summary>Stops the IMU capture.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <remarks>
/// <para>The streaming of the IMU stops as a result of this call. Once called, k4a_device_start_imu() may</para>
/// <para>be called again to resume sensor streaming, so long as the cameras are running.</para>
/// <para>This function may be called while another thread is blocking in k4a_device_get_imu_sample().</para>
/// <para>Calling this function while another thread is in that function will result in that function returning a failure.</para>
/// </remarks>
        public static void K4aDeviceStopImu(global::AzureKinectDKSharp.K4aDeviceT device_handle)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            __Internal.K4aDeviceStopImu(__arg0);
        }

        /// <summary>Get the Azure Kinect device serial number.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <param name="serial_number">
/// <para>Location to write the serial number to. If the function returns ::K4A_BUFFER_RESULT_SUCCEEDED, this will be a NULL</para>
/// <para>terminated string of ASCII characters. If this input is NULLwill still be updated to return</para>
/// <para>the size of the buffer needed to store the string.</para>
/// </param>
/// <param name="serial_number_size">
/// <para>On input, the size of thebuffer if that pointer is not NULL. On output, this value is set to the</para>
/// <para>actual number of bytes in the serial number (including the null terminator).</para>
/// </param>
/// <remarks>
/// <para>A return of ::K4A_BUFFER_RESULT_SUCCEEDED means that thehas been filled in. If the buffer is too</para>
/// <para>small the function returns ::K4A_BUFFER_RESULT_TOO_SMALL and the size of the serial number is</para>
/// <para>returned in theparameter. All other failures return ::K4A_BUFFER_RESULT_FAILED.</para>
/// <para>Queries the device for its serial number. If the caller needs to know the size of the serial number to allocate</para>
/// <para>memory, the function should be called once with a NULLto get the needed size in theoutput, and then again with the allocated buffer.</para>
/// <para>Only a complete serial number will be returned. If the caller's buffer is too small, the function will return</para>
/// <para>::K4A_BUFFER_RESULT_TOO_SMALL without returning any data in</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aBufferResultT K4aDeviceGetSerialnum(global::AzureKinectDKSharp.K4aDeviceT device_handle, sbyte* serial_number, ref ulong serial_number_size)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            fixed (ulong* __serial_number_size2 = &serial_number_size)
            {
                var __arg2 = __serial_number_size2;
                var __ret = __Internal.K4aDeviceGetSerialnum(__arg0, serial_number, __arg2);
                return __ret;
            }
        }

        /// <summary>Get the version numbers of the device's subsystems.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <param name="version">Location to write the version info to.</param>
/// <remarks>
/// <para>A return of ::K4A_RESULT_SUCCEEDED means that the version structure has been filled in.</para>
/// <para>All other failures return ::K4A_RESULT_FAILED.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aDeviceGetVersion(global::AzureKinectDKSharp.K4aDeviceT device_handle, global::AzureKinectDKSharp.K4aHardwareVersionT version)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            var __arg1 = ReferenceEquals(version, null) ? global::System.IntPtr.Zero : version.__Instance;
            var __ret = __Internal.K4aDeviceGetVersion(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Get the Azure Kinect color sensor control capabilities.</summary>
/// <param name="default_mode">Location to store the color sensor's control default mode of /p command.</param>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <param name="command">Color sensor control command.</param>
/// <param name="default_value">Location to store the color sensor's control default value of /p command.</param>
/// <param name="supports_auto">
/// <para>Location to store whether the color sensor's control support auto mode or not.</para>
/// <para>true if it supports auto mode, otherwise false.</para>
/// </param>
/// <param name="min_value">Location to store the color sensor's control minimum value of /p command.</param>
/// <param name="step_value">Location to store the color sensor's control step value of /p command.</param>
/// <param name="max_value">Location to store the color sensor's control maximum value of /p command.</param>
/// <remarks>::K4A_RESULT_SUCCEEDED if the value was successfully returned, ::K4A_RESULT_FAILED if an error occurred</remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aDeviceGetColorControlCapabilities(global::AzureKinectDKSharp.K4aDeviceT device_handle, global::AzureKinectDKSharp.K4aColorControlCommandT command, ref bool supports_auto, ref int min_value, ref int max_value, ref int step_value, ref int default_value, global::AzureKinectDKSharp.K4aColorControlModeT* default_mode)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            fixed (bool* __supports_auto2 = &supports_auto)
            {
                var __arg2 = __supports_auto2;
                fixed (int* __min_value3 = &min_value)
                {
                    var __arg3 = __min_value3;
                    fixed (int* __max_value4 = &max_value)
                    {
                        var __arg4 = __max_value4;
                        fixed (int* __step_value5 = &step_value)
                        {
                            var __arg5 = __step_value5;
                            fixed (int* __default_value6 = &default_value)
                            {
                                var __arg6 = __default_value6;
                                var __ret = __Internal.K4aDeviceGetColorControlCapabilities(__arg0, command, __arg2, __arg3, __arg4, __arg5, __arg6, default_mode);
                                return __ret;
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
/// <para>Get the Azure Kinect color sensor control</para>
/// <para>value.</para>
/// </summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <param name="command">Color sensor control command.</param>
/// <param name="mode">
/// <para>Location to store the color sensor's control mode. This mode represents whether the command is in automatic or</para>
/// <para>manual mode.</para>
/// </param>
/// <param name="value">Location to store the color sensor's control value. This value is always written, but is only valid when thereturned is ::K4A_COLOR_CONTROL_MODE_MANUAL for the current</param>
/// <remarks>
/// <para>::K4A_RESULT_SUCCEEDED if the value was successfully returned, ::K4A_RESULT_FAILED if an error occurred</para>
/// <para>Each control command may be set to manual or automatic. See the definition of</para>
/// <para>how to interpret thefor each command.</para>
/// <para>Some control commands are only supported in manual mode. When a command is in automatic mode, thefor</para>
/// <para>that command is not valid.</para>
/// <para>Control values set on a device are reset only when the device is power cycled. The device will retain the</para>
/// <para>settings even if the</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aDeviceGetColorControl(global::AzureKinectDKSharp.K4aDeviceT device_handle, global::AzureKinectDKSharp.K4aColorControlCommandT command, global::AzureKinectDKSharp.K4aColorControlModeT* mode, ref int value)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            fixed (int* __value3 = &value)
            {
                var __arg3 = __value3;
                var __ret = __Internal.K4aDeviceGetColorControl(__arg0, command, mode, __arg3);
                return __ret;
            }
        }

        /// <summary>Set the Azure Kinect color sensor control value.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <param name="command">Color sensor control command.</param>
/// <param name="mode">Color sensor control mode to set. This mode represents whether the command is in automatic or manual mode.</param>
/// <param name="value">Value to set the color sensor's control to. The value is only valid ifis set to ::K4A_COLOR_CONTROL_MODE_MANUAL, and is otherwise ignored.</param>
/// <remarks>
/// <para>::K4A_RESULT_SUCCEEDED if the value was successfully set, ::K4A_RESULT_FAILED if an error occurred</para>
/// <para>Each control command may be set to manual or automatic. See the definition of</para>
/// <para>to interpret thefor each command.</para>
/// <para>Some control commands are only supported in manual mode. When a command is in automatic mode, thefor that</para>
/// <para>command is not valid.</para>
/// <para>Control values set on a device are reset only when the device is power cycled. The device will retain the settings</para>
/// <para>even if the</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aDeviceSetColorControl(global::AzureKinectDKSharp.K4aDeviceT device_handle, global::AzureKinectDKSharp.K4aColorControlCommandT command, global::AzureKinectDKSharp.K4aColorControlModeT mode, int value)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            var __ret = __Internal.K4aDeviceSetColorControl(__arg0, command, mode, value);
            return __ret;
        }

        /// <summary>Get the raw calibration blob for the entire Azure Kinect device.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <param name="data">
/// <para>Location to write the calibration data to. This field may optionally be set to NULL for the caller to query for</para>
/// <para>the needed data size.</para>
/// </param>
/// <param name="data_size">
/// <para>On passinginto the function this variable represents the available size of thebuffer. On return this variable is updated with the amount of data actually written to the buffer, or the size</para>
/// <para>required to store the calibration buffer ifis NULL.</para>
/// </param>
/// <remarks>
/// <para>::K4A_BUFFER_RESULT_SUCCEEDED ifwas successfully written. Ifpoints to a buffer size that is</para>
/// <para>too small to hold the output oris NULL, ::K4A_BUFFER_RESULT_TOO_SMALL is returned andis</para>
/// <para>updated to contain the minimum buffer size needed to capture the calibration data.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aBufferResultT K4aDeviceGetRawCalibration(global::AzureKinectDKSharp.K4aDeviceT device_handle, byte* data, ref ulong data_size)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            fixed (ulong* __data_size2 = &data_size)
            {
                var __arg2 = __data_size2;
                var __ret = __Internal.K4aDeviceGetRawCalibration(__arg0, data, __arg2);
                return __ret;
            }
        }

        /// <summary>Get the camera calibration for the entire Azure Kinect device.</summary>
/// <param name="color_resolution">Resolution in which color camera is operated.</param>
/// <param name="depth_mode">Mode in which depth camera is operated.</param>
/// <param name="calibration">Location to write the calibration</param>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <remarks>
/// <para>k4a_calibration_3d_to_2d()</para>
/// <para>::K4A_RESULT_SUCCEEDED ifwas successfully written. ::K4A_RESULT_FAILED otherwise.</para>
/// <para>Therepresents the data needed to transform between the camera views and may be</para>
/// <para>different for each operatingandthe device is configured to operate in.</para>
/// <para>Theoutput is used as input to all calibration and transformation functions.</para>
/// <para>k4a_calibration_2d_to_2d()</para>
/// <para>k4a_calibration_2d_to_3d()</para>
/// <para>k4a_calibration_3d_to_3d()</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aDeviceGetCalibration(global::AzureKinectDKSharp.K4aDeviceT device_handle, global::AzureKinectDKSharp.K4aDepthModeT depth_mode, global::AzureKinectDKSharp.K4aColorResolutionT color_resolution, global::AzureKinectDKSharp.K4aCalibrationT calibration)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            var __arg3 = ReferenceEquals(calibration, null) ? global::System.IntPtr.Zero : calibration.__Instance;
            var __ret = __Internal.K4aDeviceGetCalibration(__arg0, depth_mode, color_resolution, __arg3);
            return __ret;
        }

        /// <summary>Get the device jack status for the synchronization in and synchronization out connectors.</summary>
/// <param name="device_handle">Handle obtained by k4a_device_open().</param>
/// <param name="sync_in_jack_connected">Upon successful return this value will be set to true if a cable is connected to this sync in jack.</param>
/// <param name="sync_out_jack_connected">Upon successful return this value will be set to true if a cable is connected to this sync out jack.</param>
/// <remarks>
/// <para>::K4A_RESULT_SUCCEEDED if the connector status was successfully read.</para>
/// <para>Ifis true then</para>
/// <para>K4A_WIRED_SYNC_MODE_STANDALONE or</para>
/// <para>k4a_device_configuration_t wired_sync_mode mode can be set to</para>
/// <para>K4A_WIRED_SYNC_MODE_SUBORDINATE.</para>
/// <para>k4a_device_start_cameras()</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aDeviceGetSyncJack(global::AzureKinectDKSharp.K4aDeviceT device_handle, ref bool sync_in_jack_connected, ref bool sync_out_jack_connected)
        {
            var __arg0 = ReferenceEquals(device_handle, null) ? global::System.IntPtr.Zero : device_handle.__Instance;
            fixed (bool* __sync_in_jack_connected1 = &sync_in_jack_connected)
            {
                var __arg1 = __sync_in_jack_connected1;
                fixed (bool* __sync_out_jack_connected2 = &sync_out_jack_connected)
                {
                    var __arg2 = __sync_out_jack_connected2;
                    var __ret = __Internal.K4aDeviceGetSyncJack(__arg0, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        /// <summary>Get the camera calibration for a device from a raw calibration blob.</summary>
/// <param name="raw_calibration">Raw calibration blob obtained from a device or recording. The raw calibration must be NULL terminated.</param>
/// <param name="raw_calibration_size">The size, in bytes, of raw_calibration including the NULL termination.</param>
/// <param name="depth_mode">Mode in which depth camera is operated.</param>
/// <param name="color_resolution">Resolution in which color camera is operated.</param>
/// <param name="calibration">Location to write the calibration.</param>
/// <remarks>
/// <para>k4a_calibration_2d_to_3d()</para>
/// <para>k4a_calibration_2d_to_2d()</para>
/// <para>Theoutput is used as input to all transformation functions.</para>
/// <para>Therepresents the data needed to transform between the camera views and is</para>
/// <para>different for each operatingandthe device is configured to operate in.</para>
/// <para>::K4A_RESULT_SUCCEEDED ifwas successfully written. ::K4A_RESULT_FAILED otherwise.</para>
/// <para>k4a_calibration_3d_to_2d()</para>
/// <para>k4a_calibration_3d_to_3d()</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aCalibrationGetFromRaw(sbyte* raw_calibration, ulong raw_calibration_size, global::AzureKinectDKSharp.K4aDepthModeT depth_mode, global::AzureKinectDKSharp.K4aColorResolutionT color_resolution, global::AzureKinectDKSharp.K4aCalibrationT calibration)
        {
            var __arg4 = ReferenceEquals(calibration, null) ? global::System.IntPtr.Zero : calibration.__Instance;
            var __ret = __Internal.K4aCalibrationGetFromRaw(raw_calibration, raw_calibration_size, depth_mode, color_resolution, __arg4);
            return __ret;
        }

        /// <summary>Transform a 3D point of a source coordinate system into a 3D point of the target coordinate system</summary>
/// <param name="calibration">Location to read the camera calibration data.</param>
/// <param name="source_point3d_mm">The 3D coordinates in millimeters representing a point in</param>
/// <param name="source_camera">The current camera.</param>
/// <param name="target_camera">The target camera.</param>
/// <param name="target_point3d_mm">
/// <para>Pointer to the output where the new 3D coordinates of the input point in the coordinate space ofis</para>
/// <para>stored in millimeters.</para>
/// </param>
/// <remarks>
/// <para>::K4A_RESULT_SUCCEEDED ifwas successfully written. ::K4A_RESULT_FAILED ifcontained invalid transformation parameters.</para>
/// <para>This function is used to transform 3D points between depth and color camera coordinate systems. The function uses the</para>
/// <para>extrinsic camera calibration. It computes the output via multiplication with a precomputed matrix encoding a 3D</para>
/// <para>rotation and a 3D translation. Ifandare the same, thenwill</para>
/// <para>be identical to</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aCalibration3dTo3d(global::AzureKinectDKSharp.K4aCalibrationT calibration, global::AzureKinectDKSharp.K4aFloat3T source_point3d_mm, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::AzureKinectDKSharp.K4aFloat3T target_point3d_mm)
        {
            var __arg0 = ReferenceEquals(calibration, null) ? global::System.IntPtr.Zero : calibration.__Instance;
            var ____arg1 = source_point3d_mm.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var ____arg4 = target_point3d_mm.__Instance;
            var __arg4 = new global::System.IntPtr(&____arg4);
            var __ret = __Internal.K4aCalibration3dTo3d(__arg0, __arg1, source_camera, target_camera, __arg4);
            return __ret;
        }

        /// <summary>
/// <para>Transform a 2D pixel coordinate with an associated depth value of the source camera into a 3D point of the target</para>
/// <para>coordinate system.</para>
/// </summary>
/// <param name="calibration">Location to read the camera calibration obtained by k4a_device_get_calibration().</param>
/// <param name="source_point2d">The 2D pixel incoordinates.</param>
/// <param name="valid">
/// <para>The output parameter returns a value of 1 if theis a valid coordinate, and will return 0 if</para>
/// <para>the coordinate is not valid in the calibration model.</para>
/// </param>
/// <param name="source_depth_mm">The depth ofin millimeters.</param>
/// <param name="source_camera">The current camera.</param>
/// <param name="target_point3d_mm">
/// <para>Pointer to the output where the 3D coordinates of the input pixel in the coordinate system ofis</para>
/// <para>stored in millimeters.</para>
/// </param>
/// <param name="target_camera">The target camera.</param>
/// <remarks>
/// <para>::K4A_RESULT_SUCCEEDED ifwas successfully written. ::K4A_RESULT_FAILED ifcontained invalid transformation parameters. If the function returns ::K4A_RESULT_SUCCEEDED, butis 0,</para>
/// <para>the transformation was computed, but the results inare outside of the range of valid</para>
/// <para>calibration and should be ignored.</para>
/// <para>This function applies the intrinsic calibration ofto compute the 3D ray from the focal point of the</para>
/// <para>camera through pixelThe 3D point on this ray is then found usingIfis different fromthe 3D point is transformed tousing</para>
/// <para>k4a_calibration_3d_to_3d(). In practice,andwill often be identical. In this</para>
/// <para>case, no 3D to 3D transformation is applied.</para>
/// <para>Ifis not considered as valid pixel coordinate</para>
/// <para>according to the intrinsic camera model,is set to 0. If it is valid,will be set to 1. The user</para>
/// <para>should not use the value ofifwas set to 0.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aCalibration2dTo3d(global::AzureKinectDKSharp.K4aCalibrationT calibration, global::AzureKinectDKSharp.K4aFloat2T source_point2d, float source_depth_mm, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::AzureKinectDKSharp.K4aFloat3T target_point3d_mm, ref int valid)
        {
            var __arg0 = ReferenceEquals(calibration, null) ? global::System.IntPtr.Zero : calibration.__Instance;
            var ____arg1 = source_point2d.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var ____arg5 = target_point3d_mm.__Instance;
            var __arg5 = new global::System.IntPtr(&____arg5);
            fixed (int* __valid6 = &valid)
            {
                var __arg6 = __valid6;
                var __ret = __Internal.K4aCalibration2dTo3d(__arg0, __arg1, source_depth_mm, source_camera, target_camera, __arg5, __arg6);
                return __ret;
            }
        }

        /// <summary>Transform a 3D point of a source coordinate system into a 2D pixel coordinate of the target camera.</summary>
/// <param name="valid">The output parameter returns a value of 1 if theis a valid coordinate in thecoordinate system, and will return 0 if the coordinate is not valid in the calibration model.</param>
/// <param name="target_point2d">Pointer to the output where the 2D pixel incoordinates is stored.</param>
/// <param name="source_camera">The current camera.</param>
/// <param name="target_camera">The target camera.</param>
/// <param name="calibration">Location to read the camera calibration obtained by k4a_device_get_calibration().</param>
/// <param name="source_point3d_mm">The 3D coordinates in millimeters representing a point in</param>
/// <remarks>
/// <para>Ifis different fromis transformed tousing</para>
/// <para>k4a_calibration_3d_to_3d(). In practice,andwill often be identical. In this</para>
/// <para>case, no 3D to 3D transformation is applied. The 3D point in the coordinate system ofis then</para>
/// <para>projected onto the image plane using the intrinsic calibration of</para>
/// <para>::K4A_RESULT_SUCCEEDED ifwas successfully written. ::K4A_RESULT_FAILED ifcontained invalid transformation parameters. If the function returns ::K4A_RESULT_SUCCEEDED, butis 0,</para>
/// <para>the transformation was computed, but the results inare outside of the range of valid calibration</para>
/// <para>and should be ignored.</para>
/// <para>Ifdoes not map to a valid 2D coordinate in thecoordinate system,is</para>
/// <para>set to 0. If it is valid,will be set to 1. The user should not use the value ofifwas set to 0.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aCalibration3dTo2d(global::AzureKinectDKSharp.K4aCalibrationT calibration, global::AzureKinectDKSharp.K4aFloat3T source_point3d_mm, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::AzureKinectDKSharp.K4aFloat2T target_point2d, ref int valid)
        {
            var __arg0 = ReferenceEquals(calibration, null) ? global::System.IntPtr.Zero : calibration.__Instance;
            var ____arg1 = source_point3d_mm.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var ____arg4 = target_point2d.__Instance;
            var __arg4 = new global::System.IntPtr(&____arg4);
            fixed (int* __valid5 = &valid)
            {
                var __arg5 = __valid5;
                var __ret = __Internal.K4aCalibration3dTo2d(__arg0, __arg1, source_camera, target_camera, __arg4, __arg5);
                return __ret;
            }
        }

        /// <summary>
/// <para>Transform a 2D pixel coordinate with an associated depth value of the source camera into a 2D pixel coordinate of</para>
/// <para>the target camera.</para>
/// </summary>
/// <param name="calibration">Location to read the camera calibration obtained by k4a_device_get_calibration().</param>
/// <param name="source_point2d">The 2D pixel incoordinates.</param>
/// <param name="source_depth_mm">The depth ofin millimeters.</param>
/// <param name="valid">The output parameter returns a value of 1 if theis a valid coordinate in thecoordinate system, and will return 0 if the coordinate is not valid in the calibration model.</param>
/// <param name="source_camera">The current camera.</param>
/// <param name="target_camera">The target camera.</param>
/// <param name="target_point2d">The 2D pixel incoordinates.</param>
/// <remarks>
/// <para>This function maps a pixel between the coordinate systems of the depth and color cameras. It is equivalent to calling</para>
/// <para>k4a_calibration_2d_to_3d() to compute the 3D point corresponding toand then using</para>
/// <para>k4a_calibration_3d_to_2d() to map the 3D point into the coordinate system of the</para>
/// <para>::K4A_RESULT_SUCCEEDED ifwas successfully written. ::K4A_RESULT_FAILED ifcontained invalid transformation parameters. If the function returns ::K4A_RESULT_SUCCEEDED, butis 0,</para>
/// <para>the transformation was computed, but the results inare outside of the range of valid calibration</para>
/// <para>and should be ignored.</para>
/// <para>Ifandare identical, the function immediately setstoand returns without computing any transformations.</para>
/// <para>Ifdoes not map to a valid 2D coordinate in thecoordinate system,is set</para>
/// <para>to 0. If it is valid,will be set to 1. The user should not use the value ofifwas set to 0.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aCalibration2dTo2d(global::AzureKinectDKSharp.K4aCalibrationT calibration, global::AzureKinectDKSharp.K4aFloat2T source_point2d, float source_depth_mm, global::AzureKinectDKSharp.K4aCalibrationTypeT source_camera, global::AzureKinectDKSharp.K4aCalibrationTypeT target_camera, global::AzureKinectDKSharp.K4aFloat2T target_point2d, ref int valid)
        {
            var __arg0 = ReferenceEquals(calibration, null) ? global::System.IntPtr.Zero : calibration.__Instance;
            var ____arg1 = source_point2d.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var ____arg5 = target_point2d.__Instance;
            var __arg5 = new global::System.IntPtr(&____arg5);
            fixed (int* __valid6 = &valid)
            {
                var __arg6 = __valid6;
                var __ret = __Internal.K4aCalibration2dTo2d(__arg0, __arg1, source_depth_mm, source_camera, target_camera, __arg5, __arg6);
                return __ret;
            }
        }

        /// <summary>Get handle to transformation handle.</summary>
/// <param name="calibration">A calibration structure obtained by k4a_device_get_calibration().</param>
/// <remarks>
/// <para>A transformation handle. A NULL is returned if creation fails.</para>
/// <para>The transformation handle is used to transform images from the coordinate system of one camera into the other. Each</para>
/// <para>transformation handle requires some pre-computed resources to be allocated, which are retained until the handle is</para>
/// <para>destroyed.</para>
/// <para>The transformation handle must be destroyed with k4a_transformation_destroy() when it is no longer to be used.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aTransformationT K4aTransformationCreate(global::AzureKinectDKSharp.K4aCalibrationT calibration)
        {
            var __arg0 = ReferenceEquals(calibration, null) ? global::System.IntPtr.Zero : calibration.__Instance;
            var __ret = __Internal.K4aTransformationCreate(__arg0);
            global::AzureKinectDKSharp.K4aTransformationT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::AzureKinectDKSharp.K4aTransformationT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::AzureKinectDKSharp.K4aTransformationT) global::AzureKinectDKSharp.K4aTransformationT.NativeToManagedMap[__ret];
            else __result0 = global::AzureKinectDKSharp.K4aTransformationT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Destroy transformation handle.</summary>
/// <param name="transformation_handle">Transformation handle to destroy.</param>
        public static void K4aTransformationDestroy(global::AzureKinectDKSharp.K4aTransformationT transformation_handle)
        {
            var __arg0 = ReferenceEquals(transformation_handle, null) ? global::System.IntPtr.Zero : transformation_handle.__Instance;
            __Internal.K4aTransformationDestroy(__arg0);
        }

        /// <summary>Transforms the depth map into the geometry of the color camera.</summary>
/// <param name="transformation_handle">Transformation handle.</param>
/// <param name="depth_image">Handle to input depth image.</param>
/// <param name="transformed_depth_image">Handle to output transformed depth image.</param>
/// <remarks>
/// <para>This produces a depth image for which each pixel matches the corresponding pixel coordinates of the color camera.</para>
/// <para>andmust be of format ::K4A_IMAGE_FORMAT_DEPTH16.</para>
/// <para>must have a width and height matching the width and height of the color camera in the mode</para>
/// <para>specified by the</para>
/// <para>The contentswill be filled with the depth values derived fromin the color</para>
/// <para>camera's coordinate space.</para>
/// <para>should be created by the caller using k4a_image_create() or</para>
/// <para>k4a_image_create_from_buffer().</para>
/// <para>::K4A_RESULT_SUCCEEDED ifwas successfully written and ::K4A_RESULT_FAILED otherwise.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aTransformationDepthImageToColorCamera(global::AzureKinectDKSharp.K4aTransformationT transformation_handle, global::AzureKinectDKSharp.K4aImageT depth_image, global::AzureKinectDKSharp.K4aImageT transformed_depth_image)
        {
            var __arg0 = ReferenceEquals(transformation_handle, null) ? global::System.IntPtr.Zero : transformation_handle.__Instance;
            var __arg1 = ReferenceEquals(depth_image, null) ? global::System.IntPtr.Zero : depth_image.__Instance;
            var __arg2 = ReferenceEquals(transformed_depth_image, null) ? global::System.IntPtr.Zero : transformed_depth_image.__Instance;
            var __ret = __Internal.K4aTransformationDepthImageToColorCamera(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Transforms a color image into the geometry of the depth camera.</summary>
/// <param name="transformation_handle">Transformation handle.</param>
/// <param name="depth_image">Handle to input depth image.</param>
/// <param name="color_image">Handle to input color image.</param>
/// <param name="transformed_color_image">Handle to output transformed color image.</param>
/// <remarks>
/// <para>This produces a color image for which each pixel matches the corresponding pixel coordinates of the depth camera.</para>
/// <para>andneed to represent the same moment in time. The depth data will be applied to the</para>
/// <para>color image to properly warp the color data to the perspective of the depth camera.</para>
/// <para>must be of type ::K4A_IMAGE_FORMAT_DEPTH16.must be of format</para>
/// <para>::K4A_IMAGE_FORMAT_COLOR_BGRA32.</para>
/// <para>image must be of format ::K4A_IMAGE_FORMAT_COLOR_BGRA32.must</para>
/// <para>have the width and height of the depth camera in the mode specified by the</para>
/// <para>thewith k4a_transformation_create().</para>
/// <para>should be created by the caller using k4a_image_create() or</para>
/// <para>k4a_image_create_from_buffer().</para>
/// <para>::K4A_RESULT_SUCCEEDED ifwas successfully written and ::K4A_RESULT_FAILED otherwise.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aTransformationColorImageToDepthCamera(global::AzureKinectDKSharp.K4aTransformationT transformation_handle, global::AzureKinectDKSharp.K4aImageT depth_image, global::AzureKinectDKSharp.K4aImageT color_image, global::AzureKinectDKSharp.K4aImageT transformed_color_image)
        {
            var __arg0 = ReferenceEquals(transformation_handle, null) ? global::System.IntPtr.Zero : transformation_handle.__Instance;
            var __arg1 = ReferenceEquals(depth_image, null) ? global::System.IntPtr.Zero : depth_image.__Instance;
            var __arg2 = ReferenceEquals(color_image, null) ? global::System.IntPtr.Zero : color_image.__Instance;
            var __arg3 = ReferenceEquals(transformed_color_image, null) ? global::System.IntPtr.Zero : transformed_color_image.__Instance;
            var __ret = __Internal.K4aTransformationColorImageToDepthCamera(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        /// <summary>Transforms the depth image into 3 planar images representing X, Y and Z-coordinates of corresponding 3D points.</summary>
/// <param name="transformation_handle">Transformation handle.</param>
/// <param name="depth_image">Handle to input depth image.</param>
/// <param name="camera">Geometry in which depth map was computed.</param>
/// <param name="xyz_image">Handle to output xyz image.</param>
/// <remarks>
/// <para>must be of format ::K4A_IMAGE_FORMAT_DEPTH16.</para>
/// <para>Theparameter tells the function what the perspective of theis. If thewas</para>
/// <para>captured directly from the depth camera, the value should be ::K4A_CALIBRATION_TYPE_DEPTH. If theis</para>
/// <para>the result of a transformation into the color camera's coordinate space using</para>
/// <para>k4a_transformation_depth_image_to_color_camera(), the value should be ::K4A_CALIBRATION_TYPE_COLOR.</para>
/// <para>The format ofmust be ::K4A_IMAGE_FORMAT_CUSTOM. The width and height ofmust match the</para>
/// <para>width and height ofmust have a stride in bytes of at least 6 times its width in pixels.</para>
/// <para>Each pixel of theconsists of three int16_t values, totaling 6 bytes. The three int16_t values are the</para>
/// <para>X, Y, and Z values of the point.</para>
/// <para>should be created by the caller using k4a_image_create() or k4a_image_create_from_buffer().</para>
/// <para>::K4A_RESULT_SUCCEEDED ifwas successfully written and ::K4A_RESULT_FAILED otherwise.</para>
/// </remarks>
        public static global::AzureKinectDKSharp.K4aResultT K4aTransformationDepthImageToPointCloud(global::AzureKinectDKSharp.K4aTransformationT transformation_handle, global::AzureKinectDKSharp.K4aImageT depth_image, global::AzureKinectDKSharp.K4aCalibrationTypeT camera, global::AzureKinectDKSharp.K4aImageT xyz_image)
        {
            var __arg0 = ReferenceEquals(transformation_handle, null) ? global::System.IntPtr.Zero : transformation_handle.__Instance;
            var __arg1 = ReferenceEquals(depth_image, null) ? global::System.IntPtr.Zero : depth_image.__Instance;
            var __arg3 = ReferenceEquals(xyz_image, null) ? global::System.IntPtr.Zero : xyz_image.__Instance;
            var __ret = __Internal.K4aTransformationDepthImageToPointCloud(__arg0, __arg1, camera, __arg3);
            return __ret;
        }
    }

    /// <summary>Result code returned by Azure Kinect APIs.</summary>
    public enum K4aResultT
    {
        /// <summary>The result was successful</summary>
        K4A_RESULT_SUCCEEDED = 0,
        /// <summary>The result was a failure</summary>
        K4A_RESULT_FAILED = 1
    }

    /// <summary>Result code returned by Azure Kinect APIs.</summary>
    public enum K4aBufferResultT
    {
        /// <summary>The result was successful</summary>
        K4A_BUFFER_RESULT_SUCCEEDED = 0,
        /// <summary>The result was a failure</summary>
        K4A_BUFFER_RESULT_FAILED = 1,
        /// <summary>The input buffer was too small</summary>
        K4A_BUFFER_RESULT_TOO_SMALL = 2
    }

    /// <summary>Result code returned by Azure Kinect APIs.</summary>
    public enum K4aWaitResultT
    {
        /// <summary>The result was successful</summary>
        K4A_WAIT_RESULT_SUCCEEDED = 0,
        /// <summary>The result was a failure</summary>
        K4A_WAIT_RESULT_FAILED = 1,
        /// <summary>The operation timed out</summary>
        K4A_WAIT_RESULT_TIMEOUT = 2
    }

    /// <summary>Verbosity levels of debug messaging</summary>
    public enum K4aLogLevelT
    {
        /// <summary>Most severe level of debug messaging.</summary>
        K4A_LOG_LEVEL_CRITICAL = 0,
        /// <summary>2nd most severe level of debug messaging.</summary>
        K4A_LOG_LEVEL_ERROR = 1,
        /// <summary>3nd most severe level of debug messaging.</summary>
        K4A_LOG_LEVEL_WARNING = 2,
        /// <summary>2nd least severe level of debug messaging.</summary>
        K4A_LOG_LEVEL_INFO = 3,
        /// <summary>Least severe level of debug messaging.</summary>
        K4A_LOG_LEVEL_TRACE = 4,
        /// <summary>No logging is performed</summary>
        K4A_LOG_LEVEL_OFF = 5
    }

    /// <summary>Depth sensor capture modes.</summary>
/// <remarks>
/// <para>See the hardware specification for additional details on the field of view, and supported frame rates</para>
/// <para>for each mode.</para>
/// <para>NFOV and WFOV denote Narrow and Wide Field Of View configurations.</para>
/// <para>Binned modes reduce the captured camera resolution by combining adjacent sensor pixels into a bin.</para>
/// </remarks>
    public enum K4aDepthModeT
    {
        /// <summary>Depth sensor will be turned off with this setting.</summary>
        K4A_DEPTH_MODE_OFF = 0,
        /// <summary>Depth captured at 320x288. Passive IR is also captured at 320x288.</summary>
        K4A_DEPTH_MODE_NFOV_2X2BINNED = 1,
        /// <summary>Depth captured at 640x576. Passive IR is also captured at 640x576.</summary>
        K4A_DEPTH_MODE_NFOV_UNBINNED = 2,
        /// <summary>Depth captured at 512x512. Passive IR is also captured at 512x512.</summary>
        K4A_DEPTH_MODE_WFOV_2X2BINNED = 3,
        /// <summary>Depth captured at 1024x1024. Passive IR is also captured at 1024x1024.</summary>
        K4A_DEPTH_MODE_WFOV_UNBINNED = 4,
        /// <summary>Passive IR only, captured at 1024x1024.</summary>
        K4A_DEPTH_MODE_PASSIVE_IR = 5
    }

    /// <summary>Color sensor resolutions.</summary>
    public enum K4aColorResolutionT
    {
        /// <summary>Color camera will be turned off with this setting</summary>
        K4A_COLOR_RESOLUTION_OFF = 0,
        /// <summary>1280 * 720  16:9</summary>
        K4A_COLOR_RESOLUTION_720P = 1,
        /// <summary>1920 * 1080 16:9</summary>
        K4A_COLOR_RESOLUTION_1080P = 2,
        /// <summary>2560 * 1440 16:9</summary>
        K4A_COLOR_RESOLUTION_1440P = 3,
        /// <summary>2048 * 1536 4:3</summary>
        K4A_COLOR_RESOLUTION_1536P = 4,
        /// <summary>3840 * 2160 16:9</summary>
        K4A_COLOR_RESOLUTION_2160P = 5,
        /// <summary>4096 * 3072 4:3</summary>
        K4A_COLOR_RESOLUTION_3072P = 6
    }

    /// <summary>Image format type.</summary>
/// <remarks>The image format indicates how the</remarks>
    public enum K4aImageFormatT
    {
        /// <summary>Color image type MJPG.</summary>
/// <remarks>
/// <para>The buffer for each image is encoded as a JPEG and can be decoded by a JPEG decoder.</para>
/// <para>Because the image is compressed, the stride parameter for the</para>
/// <para>Each MJPG encoded image in a stream may be of differing size depending on the compression efficiency.</para>
/// </remarks>
        K4A_IMAGE_FORMAT_COLOR_MJPG = 0,
        /// <summary>Color image type NV12.</summary>
/// <remarks>
/// <para>NV12 images separate the luminance and chroma data such that all the luminance is at the</para>
/// <para>beginning of the buffer, and the chroma lines follow immediately after.</para>
/// <para>Stride indicates the length of each line in bytes and should be used to determine the start location of each line</para>
/// <para>of the image in memory. Chroma has half as many lines of height and half the width in pixels of the luminance.</para>
/// <para>Each chroma line has the same width in bytes as a luminance line.</para>
/// </remarks>
        K4A_IMAGE_FORMAT_COLOR_NV12 = 1,
        /// <summary>Color image type YUY2.</summary>
/// <remarks>
/// <para>YUY2 stores chroma and luminance data in interleaved pixels.</para>
/// <para>Stride indicates the length of each line in bytes and should be used to determine the start location of each</para>
/// <para>line of the image in memory.</para>
/// </remarks>
        K4A_IMAGE_FORMAT_COLOR_YUY2 = 2,
        /// <summary>Color image type BGRA32.</summary>
/// <remarks>
/// <para>Each pixel of BGRA32 data is four bytes. The first three bytes represent Blue, Green,</para>
/// <para>and Red data. The fourth byte is the alpha channel and is unused in the Azure Kinect APIs.</para>
/// <para>Stride indicates the length of each line in bytes and should be used to determine the start location of each</para>
/// <para>line of the image in memory.</para>
/// <para>The Azure Kinect device does not natively capture in this format. Requesting images of this format</para>
/// <para>requires additional computation in the API.</para>
/// </remarks>
        K4A_IMAGE_FORMAT_COLOR_BGRA32 = 3,
        /// <summary>Depth image type DEPTH16.</summary>
/// <remarks>
/// <para>Each pixel of DEPTH16 data is two bytes of little endian unsigned depth data. The unit of the data is in</para>
/// <para>millimeters from the origin of the camera.</para>
/// <para>Stride indicates the length of each line in bytes and should be used to determine the start location of each</para>
/// <para>line of the image in memory.</para>
/// </remarks>
        K4A_IMAGE_FORMAT_DEPTH16 = 4,
        /// <summary>Image type IR16.</summary>
/// <remarks>
/// <para>Each pixel of IR16 data is two bytes of little endian unsigned depth data. The value of the data represents</para>
/// <para>brightness.</para>
/// <para>This format represents infrared light and is captured by the depth camera.</para>
/// <para>Stride indicates the length of each line in bytes and should be used to determine the start location of each</para>
/// <para>line of the image in memory.</para>
/// </remarks>
        K4A_IMAGE_FORMAT_IR16 = 5,
        /// <summary>Custom image format.</summary>
/// <remarks>
/// <para>Used in conjunction with user created images or images packing non-standard data.</para>
/// <para>See the originator of the custom formatted image for information on how to interpret the data.</para>
/// </remarks>
        K4A_IMAGE_FORMAT_CUSTOM = 6
    }

    /// <summary>Color and depth sensor frame rate.</summary>
/// <remarks>
/// <para>This enumeration is used to select the desired frame rate to operate the cameras. The actual</para>
/// <para>frame rate may vary slightly due to dropped data, synchronization variation between devices,</para>
/// <para>clock accuracy, or if the camera exposure priority mode causes reduced frame rate.</para>
/// </remarks>
    public enum K4aFpsT
    {
        /// <summary>5 FPS</summary>
        K4A_FRAMES_PER_SECOND_5 = 0,
        /// <summary>15 FPS</summary>
        K4A_FRAMES_PER_SECOND_15 = 1,
        /// <summary>30 FPS</summary>
        K4A_FRAMES_PER_SECOND_30 = 2
    }

    /// <summary>Color sensor control commands</summary>
/// <remarks>
/// <para>The current settings can be read with k4a_device_get_color_control(). The settings can be set with</para>
/// <para>k4a_device_set_color_control().</para>
/// <para>Control values set on a device are reset only when the device is power cycled. The device will retain the settings</para>
/// <para>even if the</para>
/// <para>k4a_color_control_mode_t</para>
/// </remarks>
    public enum K4aColorControlCommandT
    {
        /// <summary>Exposure time setting.</summary>
/// <remarks>
/// <para>May be set to ::K4A_COLOR_CONTROL_MODE_AUTO or ::K4A_COLOR_CONTROL_MODE_MANUAL.</para>
/// <para>Exposure time is measured in microseconds.</para>
/// </remarks>
        K4A_COLOR_CONTROL_EXPOSURE_TIME_ABSOLUTE = 0,
        /// <summary>Exposure or Framerate priority setting.</summary>
/// <remarks>
/// <para>May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL.</para>
/// <para>Value of 0 means framerate priority. Value of 1 means exposure priority.</para>
/// <para>Using exposure priority may impact the framerate of both the color and depth cameras.</para>
/// <para>Deprecated starting in 1.1.0. Please discontinue usage, firmware does not support this.</para>
/// </remarks>
        K4A_COLOR_CONTROL_AUTO_EXPOSURE_PRIORITY = 1,
        /// <summary>Brightness setting.</summary>
/// <remarks>
/// <para>May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL.</para>
/// <para>The valid range is 0 to 255. The default value is 128.</para>
/// </remarks>
        K4A_COLOR_CONTROL_BRIGHTNESS = 2,
        /// <summary>Contrast setting.</summary>
/// <remarks>May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL.</remarks>
        K4A_COLOR_CONTROL_CONTRAST = 3,
        /// <summary>Saturation setting.</summary>
/// <remarks>May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL.</remarks>
        K4A_COLOR_CONTROL_SATURATION = 4,
        /// <summary>Sharpness setting.</summary>
/// <remarks>May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL.</remarks>
        K4A_COLOR_CONTROL_SHARPNESS = 5,
        /// <summary>White balance setting.</summary>
/// <remarks>
/// <para>May be set to ::K4A_COLOR_CONTROL_MODE_AUTO or ::K4A_COLOR_CONTROL_MODE_MANUAL.</para>
/// <para>The unit is degrees Kelvin. The setting must be set to a value evenly divisible by 10 degrees.</para>
/// </remarks>
        K4A_COLOR_CONTROL_WHITEBALANCE = 6,
        /// <summary>Backlight compensation setting.</summary>
/// <remarks>
/// <para>May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL.</para>
/// <para>Value of 0 means backlight compensation is disabled. Value of 1 means backlight compensation is enabled.</para>
/// </remarks>
        K4A_COLOR_CONTROL_BACKLIGHT_COMPENSATION = 7,
        /// <summary>Gain setting.</summary>
/// <remarks>May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL.</remarks>
        K4A_COLOR_CONTROL_GAIN = 8,
        /// <summary>Powerline frequency setting.</summary>
/// <remarks>
/// <para>May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL.</para>
/// <para>Value of 1 sets the powerline compensation to 50 Hz. Value of 2 sets the powerline compensation to 60 Hz.</para>
/// </remarks>
        K4A_COLOR_CONTROL_POWERLINE_FREQUENCY = 9
    }

    /// <summary>Color sensor control mode</summary>
/// <remarks>
/// <para>The current settings can be read with k4a_device_get_color_control(). The settings can be set with</para>
/// <para>k4a_device_set_color_control().</para>
/// <para>k4a_color_control_command_t</para>
/// </remarks>
    public enum K4aColorControlModeT
    {
        /// <summary>set the associated k4a_color_control_command_t to auto</summary>
        K4A_COLOR_CONTROL_MODE_AUTO = 0,
        /// <summary>set the associated k4a_color_control_command_t to manual</summary>
        K4A_COLOR_CONTROL_MODE_MANUAL = 1
    }

    /// <summary>Synchronization mode when connecting two or more devices together.</summary>
    public enum K4aWiredSyncModeT
    {
        /// <summary>Neither 'Sync In' or 'Sync Out' connections are used.</summary>
        K4A_WIRED_SYNC_MODE_STANDALONE = 0,
        /// <summary>
/// <para>The 'Sync Out' jack is enabled and synchronization data it driven out the</para>
/// <para>connected wire.</para>
/// </summary>
        K4A_WIRED_SYNC_MODE_MASTER = 1,
        /// <summary>
/// <para>The 'Sync In' jack is used for synchronization and 'Sync Out' is driven for the</para>
/// <para>next device in the chain. 'Sync Out' is a mirror of 'Sync In' for this mode.</para>
/// </summary>
        K4A_WIRED_SYNC_MODE_SUBORDINATE = 2
    }

    /// <summary>Calibration types.</summary>
/// <remarks>Specifies a type of calibration.</remarks>
    public enum K4aCalibrationTypeT
    {
        /// <summary>Calibration type is unknown</summary>
        K4A_CALIBRATION_TYPE_UNKNOWN = -1,
        /// <summary>Depth sensor</summary>
        K4A_CALIBRATION_TYPE_DEPTH = 0,
        /// <summary>Color sensor</summary>
        K4A_CALIBRATION_TYPE_COLOR = 1,
        /// <summary>Gyroscope sensor</summary>
        K4A_CALIBRATION_TYPE_GYRO = 2,
        /// <summary>Accelerometer sensor</summary>
        K4A_CALIBRATION_TYPE_ACCEL = 3,
        /// <summary>Number of types excluding unknown type</summary>
        K4A_CALIBRATION_TYPE_NUM = 4
    }

    /// <summary>Calibration model type.</summary>
/// <remarks>
/// <para>The model used interpret the calibration parameters.</para>
/// <para>Azure Kinect devices are calibrated with Brown Conrady.</para>
/// </remarks>
    public enum K4aCalibrationModelTypeT
    {
        /// <summary>Calibration model is unknown</summary>
        K4A_CALIBRATION_LENS_DISTORTION_MODEL_UNKNOWN = 0,
        /// <summary>Calibration model is Theta (arctan)</summary>
        K4A_CALIBRATION_LENS_DISTORTION_MODEL_THETA = 1,
        /// <summary>Calibration model Polynomial 3K</summary>
        K4A_CALIBRATION_LENS_DISTORTION_MODEL_POLYNOMIAL_3K = 2,
        /// <summary>Calibration model Rational 6KT</summary>
        K4A_CALIBRATION_LENS_DISTORTION_MODEL_RATIONAL_6KT = 3,
        /// <summary>Calibration model Brown Conrady (compatible with OpenCV)</summary>
        K4A_CALIBRATION_LENS_DISTORTION_MODEL_BROWN_CONRADY = 4
    }

    /// <summary>Firmware build type.</summary>
    public enum K4aFirmwareBuildT
    {
        /// <summary>Production firmware.</summary>
        K4A_FIRMWARE_BUILD_RELEASE = 0,
        /// <summary>Pre-production firmware.</summary>
        K4A_FIRMWARE_BUILD_DEBUG = 1
    }

    /// <summary>Firmware signature type.</summary>
    public enum K4aFirmwareSignatureT
    {
        /// <summary>Microsoft signed firmware.</summary>
        K4A_FIRMWARE_SIGNATURE_MSFT = 0,
        /// <summary>Test signed firmware.</summary>
        K4A_FIRMWARE_SIGNATURE_TEST = 1,
        /// <summary>Unsigned firmware.</summary>
        K4A_FIRMWARE_SIGNATURE_UNSIGNED = 2
    }

    /// <summary>Callback function for debug messages being generated by the Azure Kinect SDK.</summary>
/// <param name="context">The context of the callback function. This is the context that was supplied by the caller to</param>
/// <param name="level">The level of the message that has been created.</param>
/// <param name="file">The file name of the source file that generated the message.</param>
/// <param name="line">The line number of the source file that generated the message.</param>
/// <param name="message">The messaged generated by the Azure Kinect SDK.</param>
/// <remarks>
/// <para>The callback is called asynchronously when the Azure Kinext SDK generates a message at athat is equal to</para>
/// <para>or more critical than the level specified when calling</para>
/// <para>This callback can occur from any thread and blocks the calling thread. The k4a_logging_message_cb_t function user</para>
/// <para>must protect it's logging resources from concurrent calls. All care should be made to minimize the amount of time</para>
/// <para>locks are held.</para>
/// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void K4aLoggingMessageCbT(global::System.IntPtr context, global::AzureKinectDKSharp.K4aLogLevelT level, [MarshalAs(UnmanagedType.LPStr)] string file, int line, [MarshalAs(UnmanagedType.LPStr)] string message);

    /// <summary>Callback function for a memory object being destroyed.</summary>
/// <param name="buffer">The buffer pointer that was supplied by the caller asto</param>
/// <param name="context">The context for the memory object that needs to be destroyed that was supplied by the caller asto</param>
/// <remarks>
/// <para>When all references for the memory object are released, this callback will be invoked as the final destroy for the</para>
/// <para>given memory.</para>
/// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void K4aMemoryDestroyCbT(global::System.IntPtr buffer, global::System.IntPtr context);

    public unsafe partial class K4aDeviceT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong _rsvd;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_device_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aDeviceT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aDeviceT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aDeviceT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aDeviceT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aDeviceT __CreateInstance(global::AzureKinectDKSharp.K4aDeviceT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aDeviceT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aDeviceT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aDeviceT.__Internal));
            *(global::AzureKinectDKSharp.K4aDeviceT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aDeviceT(global::AzureKinectDKSharp.K4aDeviceT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aDeviceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aDeviceT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aDeviceT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aDeviceT(global::AzureKinectDKSharp.K4aDeviceT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aDeviceT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aDeviceT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aDeviceT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aDeviceT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Rsvd
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aDeviceT.__Internal*) __Instance)->_rsvd;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aDeviceT.__Internal*)__Instance)->_rsvd = value;
            }
        }
    }

    public unsafe partial class K4aCaptureT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong _rsvd;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_capture_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCaptureT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCaptureT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aCaptureT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCaptureT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aCaptureT __CreateInstance(global::AzureKinectDKSharp.K4aCaptureT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCaptureT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aCaptureT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCaptureT.__Internal));
            *(global::AzureKinectDKSharp.K4aCaptureT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aCaptureT(global::AzureKinectDKSharp.K4aCaptureT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aCaptureT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aCaptureT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCaptureT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aCaptureT(global::AzureKinectDKSharp.K4aCaptureT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCaptureT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aCaptureT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aCaptureT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aCaptureT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Rsvd
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aCaptureT.__Internal*) __Instance)->_rsvd;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCaptureT.__Internal*)__Instance)->_rsvd = value;
            }
        }
    }

    public unsafe partial class K4aImageT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong _rsvd;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_image_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aImageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aImageT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aImageT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aImageT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aImageT __CreateInstance(global::AzureKinectDKSharp.K4aImageT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aImageT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aImageT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aImageT.__Internal));
            *(global::AzureKinectDKSharp.K4aImageT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aImageT(global::AzureKinectDKSharp.K4aImageT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aImageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aImageT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aImageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aImageT(global::AzureKinectDKSharp.K4aImageT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aImageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aImageT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aImageT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aImageT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Rsvd
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aImageT.__Internal*) __Instance)->_rsvd;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aImageT.__Internal*)__Instance)->_rsvd = value;
            }
        }
    }

    public unsafe partial class K4aTransformationT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong _rsvd;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_transformation_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aTransformationT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aTransformationT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aTransformationT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aTransformationT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aTransformationT __CreateInstance(global::AzureKinectDKSharp.K4aTransformationT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aTransformationT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aTransformationT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aTransformationT.__Internal));
            *(global::AzureKinectDKSharp.K4aTransformationT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aTransformationT(global::AzureKinectDKSharp.K4aTransformationT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aTransformationT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aTransformationT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aTransformationT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aTransformationT(global::AzureKinectDKSharp.K4aTransformationT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aTransformationT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aTransformationT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aTransformationT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aTransformationT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Rsvd
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aTransformationT.__Internal*) __Instance)->_rsvd;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aTransformationT.__Internal*)__Instance)->_rsvd = value;
            }
        }
    }

    /// <summary>Configuration parameters for an Azure Kinect device.</summary>
/// <remarks>Used by k4a_device_start_cameras() to specify the configuration of the data capture.</remarks>
    public unsafe partial class K4aDeviceConfigurationT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AzureKinectDKSharp.K4aImageFormatT color_format;

            [FieldOffset(4)]
            internal global::AzureKinectDKSharp.K4aColorResolutionT color_resolution;

            [FieldOffset(8)]
            internal global::AzureKinectDKSharp.K4aDepthModeT depth_mode;

            [FieldOffset(12)]
            internal global::AzureKinectDKSharp.K4aFpsT camera_fps;

            [FieldOffset(16)]
            internal byte synchronized_images_only;

            [FieldOffset(20)]
            internal int depth_delay_off_color_usec;

            [FieldOffset(24)]
            internal global::AzureKinectDKSharp.K4aWiredSyncModeT wired_sync_mode;

            [FieldOffset(28)]
            internal uint subordinate_delay_off_master_usec;

            [FieldOffset(32)]
            internal byte disable_streaming_indicator;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_device_configuration_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aDeviceConfigurationT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aDeviceConfigurationT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aDeviceConfigurationT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aDeviceConfigurationT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aDeviceConfigurationT __CreateInstance(global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aDeviceConfigurationT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal));
            *(global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aDeviceConfigurationT(global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aDeviceConfigurationT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aDeviceConfigurationT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aDeviceConfigurationT(global::AzureKinectDKSharp.K4aDeviceConfigurationT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aDeviceConfigurationT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::AzureKinectDKSharp.K4aImageFormatT ColorFormat
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) __Instance)->color_format;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*)__Instance)->color_format = value;
            }
        }

        public global::AzureKinectDKSharp.K4aColorResolutionT ColorResolution
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) __Instance)->color_resolution;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*)__Instance)->color_resolution = value;
            }
        }

        public global::AzureKinectDKSharp.K4aDepthModeT DepthMode
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) __Instance)->depth_mode;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*)__Instance)->depth_mode = value;
            }
        }

        public global::AzureKinectDKSharp.K4aFpsT CameraFps
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) __Instance)->camera_fps;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*)__Instance)->camera_fps = value;
            }
        }

        public bool SynchronizedImagesOnly
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) __Instance)->synchronized_images_only != 0;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*)__Instance)->synchronized_images_only = (byte) (value ? 1 : 0);
            }
        }

        public int DepthDelayOffColorUsec
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) __Instance)->depth_delay_off_color_usec;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*)__Instance)->depth_delay_off_color_usec = value;
            }
        }

        public global::AzureKinectDKSharp.K4aWiredSyncModeT WiredSyncMode
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) __Instance)->wired_sync_mode;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*)__Instance)->wired_sync_mode = value;
            }
        }

        public uint SubordinateDelayOffMasterUsec
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) __Instance)->subordinate_delay_off_master_usec;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*)__Instance)->subordinate_delay_off_master_usec = value;
            }
        }

        public bool DisableStreamingIndicator
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*) __Instance)->disable_streaming_indicator != 0;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*)__Instance)->disable_streaming_indicator = (byte) (value ? 1 : 0);
            }
        }
    }

    /// <summary>Extrinsic calibration data.</summary>
/// <remarks>Extrinsic calibration defines the physical relationship between two separate devices.</remarks>
    public unsafe partial class K4aCalibrationExtrinsicsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed float rotation[9];

            [FieldOffset(36)]
            internal fixed float translation[3];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_calibration_extrinsics_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT __CreateInstance(global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal));
            *(global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aCalibrationExtrinsicsT(global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aCalibrationExtrinsicsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aCalibrationExtrinsicsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aCalibrationExtrinsicsT(global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float[] Rotation
        {
            get
            {
                float[] __value = null;
                if (((global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal*) __Instance)->rotation != null)
                {
                    __value = new float[9];
                    for (int i = 0; i < 9; i++)
                        __value[i] = ((global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal*) __Instance)->rotation[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 9; i++)
                        ((global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal*)__Instance)->rotation[i] = value[i];
                }
            }
        }

        public float[] Translation
        {
            get
            {
                float[] __value = null;
                if (((global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal*) __Instance)->translation != null)
                {
                    __value = new float[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal*) __Instance)->translation[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal*)__Instance)->translation[i] = value[i];
                }
            }
        }
    }

    /// <summary>Camera intrinsic calibration data.</summary>
/// <remarks>
/// <para>Intrinsic calibration represents the internal optical properties of the camera.</para>
/// <para>Azure Kinect devices are calibrated with Brown Conrady which is compatible</para>
/// <para>with OpenCV.</para>
/// </remarks>
    public unsafe partial struct K4aCalibrationIntrinsicParametersT
    {
        [StructLayout(LayoutKind.Explicit, Size = 60)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal param;

            [FieldOffset(0)]
            internal fixed float v[15];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0k4a_calibration_intrinsic_parameters_t@@QEAA@AEBT0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        /// <summary>individual parameter or array representation of intrinsic model.</summary>
        public unsafe partial class Param : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 60)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal float cx;

                [FieldOffset(4)]
                internal float cy;

                [FieldOffset(8)]
                internal float fx;

                [FieldOffset(12)]
                internal float fy;

                [FieldOffset(16)]
                internal float k1;

                [FieldOffset(20)]
                internal float k2;

                [FieldOffset(24)]
                internal float k3;

                [FieldOffset(28)]
                internal float k4;

                [FieldOffset(32)]
                internal float k5;

                [FieldOffset(36)]
                internal float k6;

                [FieldOffset(40)]
                internal float codx;

                [FieldOffset(44)]
                internal float cody;

                [FieldOffset(48)]
                internal float p2;

                [FieldOffset(52)]
                internal float p1;

                [FieldOffset(56)]
                internal float metric_radius;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0_param@k4a_calibration_intrinsic_parameters_t@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param(native.ToPointer(), skipVTables);
            }

            internal static global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param __CreateInstance(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param(native, skipVTables);
            }

            private static void* __CopyValue(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal));
                *(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Param(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Param(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Param()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Param(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public float Cx
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->cx;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->cx = value;
                }
            }

            public float Cy
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->cy;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->cy = value;
                }
            }

            public float Fx
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->fx;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->fx = value;
                }
            }

            public float Fy
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->fy;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->fy = value;
                }
            }

            public float K1
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->k1;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->k1 = value;
                }
            }

            public float K2
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->k2;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->k2 = value;
                }
            }

            public float K3
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->k3;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->k3 = value;
                }
            }

            public float K4
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->k4;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->k4 = value;
                }
            }

            public float K5
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->k5;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->k5 = value;
                }
            }

            public float K6
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->k6;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->k6 = value;
                }
            }

            public float Codx
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->codx;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->codx = value;
                }
            }

            public float Cody
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->cody;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->cody = value;
                }
            }

            public float P2
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->p2;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->p2 = value;
                }
            }

            public float P1
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->p1;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->p1 = value;
                }
            }

            public float MetricRadius
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) __Instance)->metric_radius;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*)__Instance)->metric_radius = value;
                }
            }
        }

        private K4aCalibrationIntrinsicParametersT.__Internal __instance;
        internal K4aCalibrationIntrinsicParametersT.__Internal __Instance { get { return __instance; } }

        internal static global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT __CreateInstance(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT(native, skipVTables);
        }

        private K4aCalibrationIntrinsicParametersT(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private K4aCalibrationIntrinsicParametersT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.__Internal*) native;
        }

        public K4aCalibrationIntrinsicParametersT(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param param
        {
            get
            {
                return global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__CreateInstance(__instance.param);
            }

            set
            {
                __instance.param = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal() : *(global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.Param.__Internal*) value.__Instance;
            }
        }

        public float[] V
        {
            get
            {
                fixed (float* __arrPtr = __instance.v)
                {
                    float[] __value = null;
                    if (__arrPtr != null)
                    {
                        __value = new float[15];
                        for (int i = 0; i < 15; i++)
                            __value[i] = __arrPtr[i];
                    }
                    return __value;
                }
            }

            set
            {
                fixed (float* __arrPtr = __instance.v)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 15; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Camera sensor intrinsic calibration data.</summary>
/// <remarks>
/// <para>Intrinsic calibration represents the internal optical properties of the camera.</para>
/// <para>Azure Kinect devices are calibrated with Brown Conrady which is compatible</para>
/// <para>with OpenCV.</para>
/// </remarks>
    public unsafe partial class K4aCalibrationIntrinsicsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 68)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AzureKinectDKSharp.K4aCalibrationModelTypeT type;

            [FieldOffset(4)]
            internal uint parameter_count;

            [FieldOffset(8)]
            internal global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.__Internal parameters;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_calibration_intrinsics_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT __CreateInstance(global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal));
            *(global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aCalibrationIntrinsicsT(global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aCalibrationIntrinsicsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aCalibrationIntrinsicsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aCalibrationIntrinsicsT(global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::AzureKinectDKSharp.K4aCalibrationModelTypeT Type
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal*) __Instance)->type;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal*)__Instance)->type = value;
            }
        }

        public uint ParameterCount
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal*) __Instance)->parameter_count;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal*)__Instance)->parameter_count = value;
            }
        }

        public global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT Parameters
        {
            get
            {
                return global::AzureKinectDKSharp.K4aCalibrationIntrinsicParametersT.__CreateInstance(((global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal*) __Instance)->parameters);
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal*)__Instance)->parameters = value.__Instance;
            }
        }
    }

    /// <summary>Camera calibration contains intrinsic and extrinsic calibration information for a camera.</summary>
    public unsafe partial class K4aCalibrationCameraT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal extrinsics;

            [FieldOffset(48)]
            internal global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal intrinsics;

            [FieldOffset(116)]
            internal int resolution_width;

            [FieldOffset(120)]
            internal int resolution_height;

            [FieldOffset(124)]
            internal float metric_radius;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_calibration_camera_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCalibrationCameraT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCalibrationCameraT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aCalibrationCameraT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCalibrationCameraT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aCalibrationCameraT __CreateInstance(global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCalibrationCameraT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal));
            *(global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aCalibrationCameraT(global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aCalibrationCameraT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aCalibrationCameraT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aCalibrationCameraT(global::AzureKinectDKSharp.K4aCalibrationCameraT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aCalibrationCameraT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT Extrinsics
        {
            get
            {
                return global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__CreateInstance(new global::System.IntPtr(&((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*) __Instance)->extrinsics));
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*)__Instance)->extrinsics = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal() : *(global::AzureKinectDKSharp.K4aCalibrationExtrinsicsT.__Internal*) value.__Instance;
            }
        }

        public global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT Intrinsics
        {
            get
            {
                return global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__CreateInstance(new global::System.IntPtr(&((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*) __Instance)->intrinsics));
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*)__Instance)->intrinsics = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal() : *(global::AzureKinectDKSharp.K4aCalibrationIntrinsicsT.__Internal*) value.__Instance;
            }
        }

        public int ResolutionWidth
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*) __Instance)->resolution_width;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*)__Instance)->resolution_width = value;
            }
        }

        public int ResolutionHeight
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*) __Instance)->resolution_height;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*)__Instance)->resolution_height = value;
            }
        }

        public float MetricRadius
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*) __Instance)->metric_radius;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*)__Instance)->metric_radius = value;
            }
        }
    }

    /// <summary>Calibration type representing device calibration.</summary>
    public unsafe partial class K4aCalibrationT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1032)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal depth_camera_calibration;

            [FieldOffset(128)]
            internal global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal color_camera_calibration;

            [FieldOffset(256)]
            internal fixed byte extrinsics[16];

            [FieldOffset(1024)]
            internal global::AzureKinectDKSharp.K4aDepthModeT depth_mode;

            [FieldOffset(1028)]
            internal global::AzureKinectDKSharp.K4aColorResolutionT color_resolution;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_calibration_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCalibrationT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aCalibrationT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aCalibrationT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCalibrationT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aCalibrationT __CreateInstance(global::AzureKinectDKSharp.K4aCalibrationT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aCalibrationT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aCalibrationT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationT.__Internal));
            *(global::AzureKinectDKSharp.K4aCalibrationT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aCalibrationT(global::AzureKinectDKSharp.K4aCalibrationT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aCalibrationT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aCalibrationT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aCalibrationT(global::AzureKinectDKSharp.K4aCalibrationT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aCalibrationT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aCalibrationT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aCalibrationT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aCalibrationT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::AzureKinectDKSharp.K4aCalibrationCameraT DepthCameraCalibration
        {
            get
            {
                return global::AzureKinectDKSharp.K4aCalibrationCameraT.__CreateInstance(new global::System.IntPtr(&((global::AzureKinectDKSharp.K4aCalibrationT.__Internal*) __Instance)->depth_camera_calibration));
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationT.__Internal*)__Instance)->depth_camera_calibration = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal() : *(global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*) value.__Instance;
            }
        }

        public global::AzureKinectDKSharp.K4aCalibrationCameraT ColorCameraCalibration
        {
            get
            {
                return global::AzureKinectDKSharp.K4aCalibrationCameraT.__CreateInstance(new global::System.IntPtr(&((global::AzureKinectDKSharp.K4aCalibrationT.__Internal*) __Instance)->color_camera_calibration));
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationT.__Internal*)__Instance)->color_camera_calibration = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal() : *(global::AzureKinectDKSharp.K4aCalibrationCameraT.__Internal*) value.__Instance;
            }
        }

        public global::AzureKinectDKSharp.K4aDepthModeT DepthMode
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aCalibrationT.__Internal*) __Instance)->depth_mode;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationT.__Internal*)__Instance)->depth_mode = value;
            }
        }

        public global::AzureKinectDKSharp.K4aColorResolutionT ColorResolution
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aCalibrationT.__Internal*) __Instance)->color_resolution;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aCalibrationT.__Internal*)__Instance)->color_resolution = value;
            }
        }
    }

    /// <summary>Version information.</summary>
    public unsafe partial class K4aVersionT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint major;

            [FieldOffset(4)]
            internal uint minor;

            [FieldOffset(8)]
            internal uint iteration;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_version_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aVersionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aVersionT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aVersionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aVersionT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aVersionT __CreateInstance(global::AzureKinectDKSharp.K4aVersionT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aVersionT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aVersionT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aVersionT.__Internal));
            *(global::AzureKinectDKSharp.K4aVersionT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aVersionT(global::AzureKinectDKSharp.K4aVersionT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aVersionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aVersionT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aVersionT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aVersionT(global::AzureKinectDKSharp.K4aVersionT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aVersionT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aVersionT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aVersionT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aVersionT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Major
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aVersionT.__Internal*) __Instance)->major;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aVersionT.__Internal*)__Instance)->major = value;
            }
        }

        public uint Minor
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aVersionT.__Internal*) __Instance)->minor;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aVersionT.__Internal*)__Instance)->minor = value;
            }
        }

        public uint Iteration
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aVersionT.__Internal*) __Instance)->iteration;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aVersionT.__Internal*)__Instance)->iteration = value;
            }
        }
    }

    /// <summary>Structure to define hardware version.</summary>
    public unsafe partial class K4aHardwareVersionT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AzureKinectDKSharp.K4aVersionT.__Internal rgb;

            [FieldOffset(12)]
            internal global::AzureKinectDKSharp.K4aVersionT.__Internal depth;

            [FieldOffset(24)]
            internal global::AzureKinectDKSharp.K4aVersionT.__Internal audio;

            [FieldOffset(36)]
            internal global::AzureKinectDKSharp.K4aVersionT.__Internal depth_sensor;

            [FieldOffset(48)]
            internal global::AzureKinectDKSharp.K4aFirmwareBuildT firmware_build;

            [FieldOffset(52)]
            internal global::AzureKinectDKSharp.K4aFirmwareSignatureT firmware_signature;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_hardware_version_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aHardwareVersionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aHardwareVersionT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aHardwareVersionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aHardwareVersionT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aHardwareVersionT __CreateInstance(global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aHardwareVersionT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal));
            *(global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aHardwareVersionT(global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aHardwareVersionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aHardwareVersionT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aHardwareVersionT(global::AzureKinectDKSharp.K4aHardwareVersionT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aHardwareVersionT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::AzureKinectDKSharp.K4aVersionT Rgb
        {
            get
            {
                return global::AzureKinectDKSharp.K4aVersionT.__CreateInstance(new global::System.IntPtr(&((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*) __Instance)->rgb));
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*)__Instance)->rgb = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aVersionT.__Internal() : *(global::AzureKinectDKSharp.K4aVersionT.__Internal*) value.__Instance;
            }
        }

        public global::AzureKinectDKSharp.K4aVersionT Depth
        {
            get
            {
                return global::AzureKinectDKSharp.K4aVersionT.__CreateInstance(new global::System.IntPtr(&((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*) __Instance)->depth));
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*)__Instance)->depth = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aVersionT.__Internal() : *(global::AzureKinectDKSharp.K4aVersionT.__Internal*) value.__Instance;
            }
        }

        public global::AzureKinectDKSharp.K4aVersionT Audio
        {
            get
            {
                return global::AzureKinectDKSharp.K4aVersionT.__CreateInstance(new global::System.IntPtr(&((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*) __Instance)->audio));
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*)__Instance)->audio = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aVersionT.__Internal() : *(global::AzureKinectDKSharp.K4aVersionT.__Internal*) value.__Instance;
            }
        }

        public global::AzureKinectDKSharp.K4aVersionT DepthSensor
        {
            get
            {
                return global::AzureKinectDKSharp.K4aVersionT.__CreateInstance(new global::System.IntPtr(&((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*) __Instance)->depth_sensor));
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*)__Instance)->depth_sensor = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aVersionT.__Internal() : *(global::AzureKinectDKSharp.K4aVersionT.__Internal*) value.__Instance;
            }
        }

        public global::AzureKinectDKSharp.K4aFirmwareBuildT FirmwareBuild
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*) __Instance)->firmware_build;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*)__Instance)->firmware_build = value;
            }
        }

        public global::AzureKinectDKSharp.K4aFirmwareSignatureT FirmwareSignature
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*) __Instance)->firmware_signature;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aHardwareVersionT.__Internal*)__Instance)->firmware_signature = value;
            }
        }
    }

    /// <summary>Two dimensional floating point vector.</summary>
    public unsafe partial struct K4aFloat2T
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal xy;

            [FieldOffset(0)]
            internal fixed float v[2];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0k4a_float2_t@@QEAA@AEBT0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        /// <summary>XY or array representation of vector</summary>
        public unsafe partial class Xy : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal float x;

                [FieldOffset(4)]
                internal float y;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0_xy@k4a_float2_t@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aFloat2T.Xy> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aFloat2T.Xy>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::AzureKinectDKSharp.K4aFloat2T.Xy __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4aFloat2T.Xy(native.ToPointer(), skipVTables);
            }

            internal static global::AzureKinectDKSharp.K4aFloat2T.Xy __CreateInstance(global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4aFloat2T.Xy(native, skipVTables);
            }

            private static void* __CopyValue(global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal));
                *(global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Xy(global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Xy(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Xy()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Xy(global::AzureKinectDKSharp.K4aFloat2T.Xy _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::AzureKinectDKSharp.K4aFloat2T.Xy __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public float X
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal*) __Instance)->x;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal*)__Instance)->x = value;
                }
            }

            public float Y
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal*) __Instance)->y;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal*)__Instance)->y = value;
                }
            }
        }

        private K4aFloat2T.__Internal __instance;
        internal K4aFloat2T.__Internal __Instance { get { return __instance; } }

        internal static global::AzureKinectDKSharp.K4aFloat2T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aFloat2T(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aFloat2T __CreateInstance(global::AzureKinectDKSharp.K4aFloat2T.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aFloat2T(native, skipVTables);
        }

        private K4aFloat2T(global::AzureKinectDKSharp.K4aFloat2T.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private K4aFloat2T(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::AzureKinectDKSharp.K4aFloat2T.__Internal*) native;
        }

        public K4aFloat2T(global::AzureKinectDKSharp.K4aFloat2T _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public global::AzureKinectDKSharp.K4aFloat2T.Xy xy
        {
            get
            {
                return global::AzureKinectDKSharp.K4aFloat2T.Xy.__CreateInstance(__instance.xy);
            }

            set
            {
                __instance.xy = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal() : *(global::AzureKinectDKSharp.K4aFloat2T.Xy.__Internal*) value.__Instance;
            }
        }

        public float[] V
        {
            get
            {
                fixed (float* __arrPtr = __instance.v)
                {
                    float[] __value = null;
                    if (__arrPtr != null)
                    {
                        __value = new float[2];
                        for (int i = 0; i < 2; i++)
                            __value[i] = __arrPtr[i];
                    }
                    return __value;
                }
            }

            set
            {
                fixed (float* __arrPtr = __instance.v)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Three dimensional floating point vector.</summary>
    public unsafe partial struct K4aFloat3T
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal xyz;

            [FieldOffset(0)]
            internal fixed float v[3];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0k4a_float3_t@@QEAA@AEBT0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        /// <summary>XYZ or array representation of vector.</summary>
        public unsafe partial class Xyz : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal float x;

                [FieldOffset(4)]
                internal float y;

                [FieldOffset(8)]
                internal float z;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0_xyz@k4a_float3_t@@QEAA@AEBU01@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aFloat3T.Xyz> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aFloat3T.Xyz>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::AzureKinectDKSharp.K4aFloat3T.Xyz __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4aFloat3T.Xyz(native.ToPointer(), skipVTables);
            }

            internal static global::AzureKinectDKSharp.K4aFloat3T.Xyz __CreateInstance(global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal native, bool skipVTables = false)
            {
                return new global::AzureKinectDKSharp.K4aFloat3T.Xyz(native, skipVTables);
            }

            private static void* __CopyValue(global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal));
                *(global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Xyz(global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Xyz(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Xyz()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Xyz(global::AzureKinectDKSharp.K4aFloat3T.Xyz _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::AzureKinectDKSharp.K4aFloat3T.Xyz __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public float X
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal*) __Instance)->x;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal*)__Instance)->x = value;
                }
            }

            public float Y
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal*) __Instance)->y;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal*)__Instance)->y = value;
                }
            }

            public float Z
            {
                get
                {
                    return ((global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal*) __Instance)->z;
                }

                set
                {
                    ((global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal*)__Instance)->z = value;
                }
            }
        }

        private K4aFloat3T.__Internal __instance;
        internal K4aFloat3T.__Internal __Instance { get { return __instance; } }

        internal static global::AzureKinectDKSharp.K4aFloat3T __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aFloat3T(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aFloat3T __CreateInstance(global::AzureKinectDKSharp.K4aFloat3T.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aFloat3T(native, skipVTables);
        }

        private K4aFloat3T(global::AzureKinectDKSharp.K4aFloat3T.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private K4aFloat3T(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::AzureKinectDKSharp.K4aFloat3T.__Internal*) native;
        }

        public K4aFloat3T(global::AzureKinectDKSharp.K4aFloat3T _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public global::AzureKinectDKSharp.K4aFloat3T.Xyz xyz
        {
            get
            {
                return global::AzureKinectDKSharp.K4aFloat3T.Xyz.__CreateInstance(__instance.xyz);
            }

            set
            {
                __instance.xyz = ReferenceEquals(value, null) ? new global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal() : *(global::AzureKinectDKSharp.K4aFloat3T.Xyz.__Internal*) value.__Instance;
            }
        }

        public float[] V
        {
            get
            {
                fixed (float* __arrPtr = __instance.v)
                {
                    float[] __value = null;
                    if (__arrPtr != null)
                    {
                        __value = new float[3];
                        for (int i = 0; i < 3; i++)
                            __value[i] = __arrPtr[i];
                    }
                    return __value;
                }
            }

            set
            {
                fixed (float* __arrPtr = __instance.v)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 3; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>IMU sample.</summary>
    public unsafe partial class K4aImuSampleT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float temperature;

            [FieldOffset(4)]
            internal global::AzureKinectDKSharp.K4aFloat3T.__Internal acc_sample;

            [FieldOffset(16)]
            internal ulong acc_timestamp_usec;

            [FieldOffset(24)]
            internal global::AzureKinectDKSharp.K4aFloat3T.__Internal gyro_sample;

            [FieldOffset(40)]
            internal ulong gyro_timestamp_usec;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("AzureKinectDKSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_k4a_imu_sample_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aImuSampleT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AzureKinectDKSharp.K4aImuSampleT>();
        protected internal void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::AzureKinectDKSharp.K4aImuSampleT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aImuSampleT(native.ToPointer(), skipVTables);
        }

        internal static global::AzureKinectDKSharp.K4aImuSampleT __CreateInstance(global::AzureKinectDKSharp.K4aImuSampleT.__Internal native, bool skipVTables = false)
        {
            return new global::AzureKinectDKSharp.K4aImuSampleT(native, skipVTables);
        }

        private static void* __CopyValue(global::AzureKinectDKSharp.K4aImuSampleT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aImuSampleT.__Internal));
            *(global::AzureKinectDKSharp.K4aImuSampleT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private K4aImuSampleT(global::AzureKinectDKSharp.K4aImuSampleT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected K4aImuSampleT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public K4aImuSampleT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aImuSampleT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public K4aImuSampleT(global::AzureKinectDKSharp.K4aImuSampleT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::AzureKinectDKSharp.K4aImuSampleT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*) __Instance) = *((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::AzureKinectDKSharp.K4aImuSampleT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Temperature
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*) __Instance)->temperature;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*)__Instance)->temperature = value;
            }
        }

        public global::AzureKinectDKSharp.K4aFloat3T AccSample
        {
            get
            {
                return global::AzureKinectDKSharp.K4aFloat3T.__CreateInstance(((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*) __Instance)->acc_sample);
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*)__Instance)->acc_sample = value.__Instance;
            }
        }

        public ulong AccTimestampUsec
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*) __Instance)->acc_timestamp_usec;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*)__Instance)->acc_timestamp_usec = value;
            }
        }

        public global::AzureKinectDKSharp.K4aFloat3T GyroSample
        {
            get
            {
                return global::AzureKinectDKSharp.K4aFloat3T.__CreateInstance(((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*) __Instance)->gyro_sample);
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*)__Instance)->gyro_sample = value.__Instance;
            }
        }

        public ulong GyroTimestampUsec
        {
            get
            {
                return ((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*) __Instance)->gyro_timestamp_usec;
            }

            set
            {
                ((global::AzureKinectDKSharp.K4aImuSampleT.__Internal*)__Instance)->gyro_timestamp_usec = value;
            }
        }
    }

    public unsafe partial class k4atypes
    {
        public partial struct __Internal
        {
        }

        /// <summary>Initial configuration setting for disabling all sensors.</summary>
/// <remarks>Use this setting to initialize a</remarks>
        //public static global::AzureKinectDKSharp.K4aDeviceConfigurationT K4A_DEVICE_CONFIG_INIT_DISABLE_ALL
        //{
        //    //get
        //    //{
        //    //    var __ptr = (global::AzureKinectDKSharp.K4aDeviceConfigurationT.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("AzureKinectDKSharp", "K4A_DEVICE_CONFIG_INIT_DISABLE_ALL");
        //    //    return global::AzureKinectDKSharp.K4aDeviceConfigurationT.__CreateInstance(*__ptr);
        //    //}
        //}
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_int(global::System.IntPtr __instance, int arg1);
    }
}
